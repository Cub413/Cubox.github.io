<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CUBOX</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  font-family: 'Press Start 2P', monospace;
}

canvas {
  display: block;
  background: #87CEEB;
  font-family: 'Press Start 2P', monospace;
}


/* Contenedor de controles */
/* Contenedor normal de controles */
#controls {
  position: fixed;
  bottom: 10px;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between;
  padding: 0 20px;
  pointer-events: none; /* ‚Üê importante, evita que tape clicks */
}

.left-controls,
.right-controls {
  display: flex;
  gap: 10px;
  pointer-events: auto; /* ‚Üê los hijos s√≠ reciben toques */
}

/* Fondo borroso */
#blur-bg {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  backdrop-filter: blur(5px);
  background: rgba(0,0,0,0.2);
  display: none;
  z-index: 900;
}

/* Bot√≥n de pausa peque√±o */
#pause-btn {
  position: fixed;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  width: 40px;
  height: 30px;
  background-color: rgba(100,100,100,0.6);
  color: white;
  border: 2px solid white;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  z-index: 1000;
  touch-action: manipulation;
  display: flex;
  flex-direction: column;
  justify-content: space-around; /* distribuye las barras */
  align-items: center;
  box-sizing: border-box;
}



/* Men√∫ de pausa */
#pause-menu {
  position: fixed;
  top: 100px;
  left: 50%;
  transform: translateX(-50%);
  width: 250px;
  background-color: rgba(100,100,100,0.6);
  border: 2px solid #000;
  display: none;
  flex-direction: column;
  align-items: center;
  font-family: 'Press Start 2P', monospace;
  z-index: 1001;
}

.menu-btn {
  margin: 5px;
  font-size: 16px;
padding: 5px 10px;
background: #2ecc71;
color: black;
border: 4px solid #000;
cursor: pointer;
image-rendering: pixelated;
box-shadow: 4px 4px 0 #000;
transition: transform 0.1s;

font-family: 'Press Start 2P',
monospace;
}
/* Panel de ajustes deslizable desde la derecha */
#settings-panel {
  position: fixed;
  top: 50px;
  right: -240px; /* fuera de la pantalla al inicio */
  width: 220px;
  height: 250px;
  background-color: rgba(100,100,100,0.6);
  border: 2px solid #000;
  display: flex;
  flex-direction: column;
  z-index: 1002;
  transition: right 0.3s ease;
}

#settings-panel.active {
  right: 10px; /* cuando est√° abierto */
}

#settings-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: rgba(100,100,100,0.6);
  border-bottom: 1px solid #000000;
  padding: 4px 8px;
  font-family: 'Press Start 2P', monospace;
}

#close-settings {
  cursor: pointer;
}

#settings-content {
  flex: 1;
  overflow-y: auto;
  padding: 6px;
}
#volume-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  background: #4A00FF59;
  border: 2px solid #03F2FF;
  
  padding: 4px 8px;
  margin: 6px 0;
  font-family: 'Press Start 2P', monospace;
}

#volume-controls button {
  background: #00FFAB;
  color: #000;
  border: 2px solid #000;
  border-radius: 4px;
  padding: 4px 8px;
  margin: 0 4px;
  cursor: pointer;
  font-family: 'Press Start 2P', monospace;
}

#volume-controls button:hover {
  background: #666;
}

#vol-label {
  min-width: 30px;
  text-align: center;
}

p {
  font-family: 'Press Start 2P', monospace;
  margin: 6px 0;
  text-align: center;
}

#music-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 10px 0;
  gap: 8px;
}

#prevTrack,
#nextTrack {
  background-color: #0029FF;
  color: #fff;
  border: 2px solid #000;
  
  padding: 6px 12px;
  cursor: pointer;
  font-family: 'Press Start 2P', monospace;
  transition: background 0.2s;
  font-size: 10px;
}

#prevTrack:hover,
#nextTrack:hover {
  background-color: #13FF00;
}

#currentTrack {
  font-family: 'Press Start 2P', monospace;
  min-width: 120px;
  max-width: 180px;
  text-align: center;
  display: inline-block;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 8px; /* texto m√°s peque√±o */
}

.setting-btn {
  background: #09FF003B;
  color: #000;
  border: 2px solid #000;
  padding: 6px;
  margin: 4px 0;
  width: 100%;
  text-align: center;
  cursor: pointer;
  user-select: none;
}

/* Bot√≥n PRI separado y m√°s arriba */
#pri-container {
  position: fixed;
  right: 10px;
  bottom: 100px; /* m√°s arriba que los otros botones */
  z-index: 10;
}

/* Estilo com√∫n para todos los botones */
.control-btn {
  width: 64px;
  height: 40px;
  background-color: rgba(100, 100, 100, 0.5);
  border: 2px solid white;
  color: white;
  text-align: center;
  line-height: 40px;
  font-weight: bold;
  border-radius: 8px;
  user-select: none;
  touch-action: none;
}

/* PRI activo */
#pri-btn.active {
  background-color: rgba(200, 50, 50, 0.7);
}



.control-btn.active {
  outline: 3px solid yellow; /* borde sin afectar tama√±o */
  border: 2px solid white;   /* borde original se mantiene */
  box-shadow: none;
  transform: none;
}




#inventory-btn {
  position: fixed;
  left: 10px;
  bottom: 100px;
  width: 60px;
  height: 40px;
  background-color: rgba(100, 100, 100, 0.6);
  color: white;
  border: 2px solid white;
  border-radius: 6px;
  font-weight: bold;
  font-family: 'Press Start 2P', monospace;
  cursor: pointer;
  z-index: 40;
  touch-action: manipulation;
  display: flex;
  justify-content: center;
  align-items: center;
}

#inventory-btn:active {
  background-color: rgba(120, 120, 120, 0.8);
}


#fps-counter {
  position: fixed;
  top: 5px;
  left: 5px;
  color: white;
  background: rgba(0, 0, 0, 0.5);
  padding: 4px 6px;
  border-radius: 4px;
  font-family: 'Press Start 2P', monospace;
  display: none;
  font-size: 10px;
  z-index: 50;
}


#object-controls {
  position: fixed;
  bottom: 10px;
  left: 300px;
  width: 220px;
  background: #111;
  border: 2px solid #0f0;
  color: #0f0;
  font-family: monospace;
  padding: 10px;
  z-index: 100;
  user-select: none;
  box-shadow: 4px 4px 0 #000;
  cursor: grab;
}

#object-controls.dragging {
  cursor: grabbing;
}

#settings-header {
  font-weight: bold;
  text-align: center;
  margin-bottom: 5px;
}

#panel-msg {
  text-align: center;
  font-size: 12px;
  color: #ff0;
  opacity: 0;
  transition: opacity 0.3s;
  margin-bottom: 5px;
}

.control-row {
  display: flex;
  justify-content: space-between;
  margin: 3px 0;
}

button {
  background: #222;
  color: #0f0;
  border: 2px solid #0f0;
  font-family: monospace;
  cursor: pointer;
  padding: 2px 5px;
  user-select: none;
}

button:active {
  background: #0f0;
  color: #222;
}
#orientation-panel {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  backdrop-filter: blur(8px);
  background-color: rgba(0,0,0,0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

#orientation-panel img {
  max-width: 80%;
  max-height: 80%;
}

.hidden {
  display: none;
}
/* ===== INVENTARIO GENERAL ===== */
#inventory-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #141414AB;
  padding: 12px;
  border: 3px solid #000000;
  border-radius: 8px;
  display: none; /* Se muestra al abrir inventario */
  z-index: 30;
  font-family: monospace;
  color: white;
  transform-origin: center;
  zoom: 0.8; /* Ajusta tama√±o general */
}

/* Grid del inventario (9x3) */
#inventory-grid {
  display: grid;
  grid-template-columns: repeat(9, 36px);
  gap: 4px;
  margin-bottom: 10px;
  justify-content: center;
}

/* Hotbar dentro del inventario */
#hotbar {
  display: none;
}

/* ===== SLOTS ===== */
.slot {
  width: 36px;
  height: 36px;
  background: #0000005E;
  border: 2px solid black;
  border-radius: 3px;
  cursor: pointer;
  position: relative;
  overflow: hidden;
}

.slot img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  pointer-events: none;
}

.slot.selected {
  border: 2px solid #00FF2E;
}


/* ===== CRAFTING ===== */
#crafting-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  margin-top: 10px;
}

/* Grid de 2x2 */
#crafting-grid {
  display: grid;
  grid-template-columns: repeat(2, 36px);
  grid-template-rows: repeat(2, 36px);
  gap: 4px;
}

.craft-slot {
  background: #444;
  border: 2px solid black;
}

/* Flecha de crafteo */
.arrow {
  font-size: 18px;
  font-weight: bold;
  color: white;
}

/* Resultado de crafteo */
#craft-result {
  background: #42764A;
  border: 2px solid black;
}

/* ===== HOTBAR FIJA EN PANTALLA ===== */
#hotbar-fixed {
  position: fixed;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 4px;
  background: rgba(0,0,0,0.5);
  padding: 4px;
  border-radius: 6px;
  z-index: 20;
}

#hotbar-fixed .slot {
  width: 34px;
  height: 34px;
}
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
#split-count {
  font-family: 'Press Start 2P', monospace;
  font-size: 14px;
  color: white;
  padding: 0 6px;
}

#overlay413 {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  backdrop-filter: blur(8px);
  background: rgba(0,0,0,0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}
/* Contenedor */
#quality-controls {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  padding: 10px;
  background-color: #222; /* fondo oscuro */
  border: 4px solid #555; /* borde grueso estilo pixel */
  width: max-content;
  font-family: 'Press Start 2P', monospace; /* fuente pixelada */
  user-select: none;
}

/* Texto */
#quality-controls p {
  margin: 0;
  color: #fff;
  font-size: 12px;
  text-shadow: 1px 1px 0 #000;
}

/* Botones pixel art */
.q-btn {
  background-color: #888; /* color base */
  color: #fff;
  border: 4px solid #555; /* borde grueso */
  padding: 8px 16px;
  cursor: pointer;
  font-family: 'Press Start 2P', monospace;
  font-size: 10px;
  text-shadow: 1px 1px 0 #000;
  transition: all 0.1s; /* efecto r√°pido */
  outline: none;
  image-rendering: pixelated; /* efecto pixel */
}

/* Hover y activo */
.q-btn:hover {
  background-color: #aaa;
  border-color: #fff;
}

.q-btn:active {
  background-color: #666;
  border-color: #333;
  transform: translate(1px, 1px); /* efecto de ‚Äúpresionado‚Äù */
}

/* Espaciado entre botones */
.q-btn + .q-btn {
  margin-left: 4px;
}

#starmp3 {
  font-size: 16px;
  padding: 20px 40px;
  background: #2ecc71;
  color: black;
  border: 4px solid #000;
  cursor: pointer;
  image-rendering: pixelated;
  box-shadow: 4px 4px 0 #000;
  transition: transform 0.1s;
  animation: blink413 1s step-start infinite;
  font-family: 'Press Start 2P', monospace;
}

#starmp3:active {
  transform: translate(2px, 2px);
  box-shadow: 2px 2px 0 #000;
}

@keyframes blink413 {
  50% { opacity: 0.4; }
}

.slot .count {
  position: absolute;
  bottom: 2px;
  right: 2px;
  color: white;
  font-size: 10px;
  font-family: 'Press Start 2P', monospace;
  image-rendering: pixelated;
  text-shadow: 1px 1px 0 #000; /* contorno negro para m√°s contraste */
  pointer-events: none;
}

</style>
</head>
<body>
  <div id="overlay413">
  <button id="starmp3">‚ñ∂ COMENZAR</button>
</div>

<audio id="player413"></audio>

  <div id="orientation-panel">
  <img src="Texturas/horizontal.png" alt="Gira pantalla">
</div>


<div id="pause-btn">‚ñê‚ñê</div>
<div id="blur-bg"></div>



<div id="pause-menu">
  <div class="menu-btn" id="resume-btn">Reanudar</div>
  <div class="menu-btn" id="exit-btn">Salir</div>
  <div class="menu-btn" id="settings-btn">Ajustes</div>
</div>

<div id="settings-panel">
    <div id="settings-header">
      Ajustes
      <div id="close-settings">√ó</div>
    </div>
    <div id="settings-content">
    

<h3>volumen de musica</h3>
<div id="volume-controls">
  <button id="vol-down">-</button>
  <span id="vol-label">50</span>
  <button id="vol-up">+</button>
</div>
<p>musica:</p>
<div id="music-controls">
  <button id="prevTrack">Ô∏è<</button>
  <span id="currentTrack">[Nombre de la m√∫sica]</span>
  <button id="nextTrack">Ô∏è></button>
</div>
<div id="quality-controls">
  <p>Calidad gr√°fica:</p>
  <button class="q-btn" data-scale="0.5">Bajo</button>
  <button class="q-btn" data-scale="1">Medio</button>
  <button class="q-btn" data-scale="2">Alto (2K)</button>
  <button class="q-btn" data-scale="4">Ultra (4K)</button>
</div>
<div id="particles-toggle" class="setting-btn">part√≠culas: s√≠</div>

      <div id="fps-toggle" class="setting-btn">mostrar fps: no</div>
     
    </div>
  </div>

  <div id="fps-counter"></div>

<canvas id="gameCanvas"></canvas>
<!-- Hotbar fija en pantalla -->
<!-- Bot√≥n para abrir inventario -->
<button id="inventory-btn">INV</button>

<!-- INVENTARIO Y CRAFTING -->
<div id="inventory-panel">
  <!-- Grid del inventario 9x3 -->
  <div id="inventory-grid">
    <!-- 27 slots de ejemplo -->
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>

    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
  </div>
<!-- Crafting 3x3 oculto al inicio -->
<div id="crafting-section-3x3" style="display:none; gap:10px; margin-top:10px; align-items:center; justify-content:center;">
  <div id="crafting-grid-3x3" style="display:grid; grid-template-columns:repeat(3,36px); grid-template-rows:repeat(3,36px); gap:4px;">
    <button class="slot craft-slot-3x3"></button>
    <button class="slot craft-slot-3x3"></button>
    <button class="slot craft-slot-3x3"></button>
    <button class="slot craft-slot-3x3"></button>
    <button class="slot craft-slot-3x3"></button>
    <button class="slot craft-slot-3x3"></button>
    <button class="slot craft-slot-3x3"></button>
    <button class="slot craft-slot-3x3"></button>
    <button class="slot craft-slot-3x3"></button>
  </div>
  <div class="arrow">‚û°</div>
  <button class="slot" id="craft-result-3x3"></button>
</div>

  <!-- Crafting 2x2 -->
  <div id="crafting-section">
    <div id="crafting-grid">
      <button class="slot craft-slot"></button>
      <button class="slot craft-slot"></button>
      <button class="slot craft-slot"></button>
      <button class="slot craft-slot"></button>
    </div>
    <div class="arrow">‚û°</div>
    <button class="slot" id="craft-result"></button>
  </div>

  <!-- Hotbar dentro del inventario -->
  <div id="hotbar">
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
  </div>
</div>

<!-- Hotbar fija abajo -->
<div id="hotbar-fixed">
  <button class="slot"></button>
  <button class="slot"></button>
  <button class="slot"></button>
  <button class="slot"></button>
  <button class="slot"></button>
  <button class="slot"></button>
  <button class="slot"></button>
  <button class="slot"></button>
  <button class="slot"></button>
</div>


<div id="controls">
  <div class="left-controls">
    <div class="control-btn" id="left">‚óÄ</div>
    <div class="control-btn" id="right">‚ñ∂</div>
  </div>
  <div class="right-controls">
    <div class="control-btn" id="down">‚ñº</div>
    <div class="control-btn" id="jump">‚ñ≤</div>
  </div>
</div>

<div id="pri-container">
  <div class="control-btn" id="pri-btn">PRI</div>
  <div class="control-btn" id="pri-bg-btn">BG</div>
</div>

</div>
<div id="split-panel" style="
  position: fixed; 
  top: 50%; left: 50%; 
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.85);
  padding: 10px;
  border: 2px solid white;
  border-radius: 6px;
  color: white;
  display: none;
  z-index: 2000;
  text-align: center;
  font-family: monospace;">

  <div style="margin-bottom: 8px;">
    <button id="split-min">--</button>
    <button id="split-minus">-</button>
    <span id="split-count">1</span>
    <button id="split-plus">+</button>
    <button id="split-max">++</button>
  </div>

  <div>
    <button id="split-confirm">‚úîÔ∏è</button>
    <button id="split-cancel">‚ùå</button>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width = window.innerWidth;
let height = window.innerHeight;

const scale = window.devicePixelRatio || 1; // detecta si es 2K, 4K, etc.
canvas.width = width * scale;
canvas.height = height * scale;
canvas.style.width = width + "px";
canvas.style.height = height + "px";
ctx.scale(scale, scale);


let BLOCK_SIZE = 100; // valor inicial

function setZoom(level) {
  BLOCK_SIZE = level; // ejemplo: setZoom(80) ‚Üí m√°s cerca
}
let selectedObject = null;
const factoryStyles = new WeakMap();
const panel2 = document.getElementById('orientation-panel');

// Solo mostrar el panel si se carga en vertical
if(window.innerWidth > window.innerHeight){
  panel2.style.display = 'none';
}
const qButtons = document.querySelectorAll(".q-btn");

function resizeCanvas(scale) {
  width  = window.innerWidth;
  height = window.innerHeight;

  // el canvas renderiza a m√°s p√≠xeles internos
  canvas.width  = width * scale;
  canvas.height = height * scale;

  // pero se escala visualmente al tama√±o real de pantalla
  canvas.style.width  = width + "px";
  canvas.style.height = height + "px";

  ctx.setTransform(1, 0, 0, 1, 0, 0); // reset
  ctx.scale(scale, scale);

  // guardar preferencia
  localStorage.setItem("gameQuality", scale);
}

// cargar preferencia guardada
const savedQuality = localStorage.getItem("gameQuality");
if (savedQuality) {
  resizeCanvas(parseFloat(savedQuality));
}

// evento para los botones
qButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    const scale = parseFloat(btn.dataset.scale);
    resizeCanvas(scale);
  });
});

let lastOrientation = window.innerWidth > window.innerHeight;

setInterval(() => {
  const isHorizontal = window.innerWidth > window.innerHeight;

  if(isHorizontal !== lastOrientation){
    lastOrientation = isHorizontal;

    // Si gira a horizontal desde vertical, recarga
    if(isHorizontal){
      location.reload();
    }
  }
}, 300);


window.addEventListener("load", () => {
  const starmp3 = document.getElementById("starmp3");
  const player413 = document.getElementById("player413");
  const overlay413 = document.getElementById("overlay413");
  const currentTrackElem = document.getElementById("currentTrack");
  const prevTrackBtn = document.getElementById("prevTrack");
  const nextTrackBtn = document.getElementById("nextTrack");
const particlesToggle = document.getElementById("particles-toggle");
particlesToggle.addEventListener("click", () => {
  particlesEnabled = !particlesEnabled;
  particlesToggle.textContent = "part√≠culas: " + (particlesEnabled ? "s√≠" : "no");
});

  const tracks413 = [
    "Texturas/Explorer.webm",
    "Texturas/far.webm",
    "Texturas/Home.webm",
    "Texturas/RLX.webm"
  ];

  let playlist413 = [];
  let playedTracks = [];
  let currentTrack = "";

  function shufflePlaylist() {
    playlist413 = [...tracks413];
    playedTracks = [];
    pickNextTrack();
  }

  function pickNextTrack() {
    if (playlist413.length === 0) {
      playlist413 = [...playedTracks];
      playedTracks = [];
    }
    const randomIndex = Math.floor(Math.random() * playlist413.length);
    currentTrack = playlist413.splice(randomIndex, 1)[0];
    playedTracks.push(currentTrack);
    updateCurrentTrackDisplay();
    player413.src = currentTrack;
    player413.play().catch(err => console.error(err));
  }

  function pickPrevTrack() {
    if (playedTracks.length > 1) {
      playlist413.unshift(playedTracks.pop());
      currentTrack = playedTracks[playedTracks.length - 1];
      updateCurrentTrackDisplay();
      player413.src = currentTrack;
      player413.play().catch(err => console.error(err));
    }
  }

  function updateCurrentTrackDisplay() {
    const name = currentTrack.split("/").pop();
    currentTrackElem.textContent = `<${name}>`;
  }

  function openFullscreen() {
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen();
    } else if (document.documentElement.webkitRequestFullscreen) {
      document.documentElement.webkitRequestFullscreen();
    } else if (document.documentElement.msRequestFullscreen) {
      document.documentElement.msRequestFullscreen();
    }
  }

  starmp3.addEventListener("click", async () => {
    try {
      openFullscreen();
      shufflePlaylist();
      overlay413.style.display = "none";
      player413.muted = false;
      player413.volume = (window.orientation === 90 || window.orientation === -90) ? 1 : 0;
      await player413.play();
    } catch(e) {
      console.error("Error al reproducir audio:", e);
    }
  });

  window.addEventListener("orientationchange", () => {
    if (player413.src) {
      player413.volume = (window.orientation === 90 || window.orientation === -90) ? 1 : 0;
    }
  });

  prevTrackBtn.addEventListener("click", pickPrevTrack);
  nextTrackBtn.addEventListener("click", pickNextTrack);

  // --- aqu√≠ se reproduce la siguiente autom√°ticamente ---
  player413.addEventListener("ended", pickNextTrack);
});

// --- controles de volumen ---
const volDown = document.getElementById("vol-down");
const volUp   = document.getElementById("vol-up");
const volLabel = document.getElementById("vol-label");

// volumen inicial (cargar desde localStorage o usar 0.5 por defecto)
let volume = parseFloat(localStorage.getItem("musicVolume")) || 0.5;
player413.volume = volume;
volLabel.textContent = Math.round(volume * 100);

// actualizar volumen en pantalla y guardar
function updateVolume() {
  player413.volume = volume;
  volLabel.textContent = Math.round(volume * 100);
  localStorage.setItem("musicVolume", volume.toFixed(2));
}

// bajar volumen
volDown.addEventListener("click", () => {
  volume = Math.max(0, volume - 0.1);
  updateVolume();
});

// subir volumen
volUp.addEventListener("click", () => {
  volume = Math.min(1, volume + 0.1);
  updateVolume();
});

let fpsVisible = false;
let fpsCounter = document.getElementById("fps-counter");
let fpsToggle = document.getElementById("fps-toggle");

let fpsValues = []; // guardamos varios FPS para hacer promedio
let lastFrame = performance.now();

// Alternar bot√≥n
fpsToggle.addEventListener("click", () => {
  fpsVisible = !fpsVisible;
  fpsToggle.textContent = "mostrar fps: " + (fpsVisible ? "s√≠" : "no");
  fpsCounter.style.display = fpsVisible ? "block" : "none";
});

// Loop para calcular fps por frame
function frameLoop() {
  let now = performance.now();
  let delta = (now - lastFrame) / 1000; // en segundos
  lastFrame = now;

  let fps = 1 / delta;
  fpsValues.push(fps);

  requestAnimationFrame(frameLoop);
}
frameLoop();

// Mostrar promedio cada 3 segundos
setInterval(() => {
  if (fpsVisible && fpsValues.length > 0) {
    let sum = fpsValues.reduce((a, b) => a + b, 0);
    let avg = Math.round(sum / fpsValues.length);
    fpsCounter.textContent = "FPS: " + avg;
    fpsValues = []; // vaciar para el siguiente ciclo
  }
}, 1000);

const ROWS = 100;
const CHUNK_SIZE = 10;

// Texturas
const textures = {};
textures.grass = new Image(); textures.grass.src = 'Texturas/cesped_parte_costado.jpg';
textures.dirt = new Image(); textures.dirt.src = 'Texturas/tierra.jpg';
textures.stone = new Image(); textures.stone.src = 'Texturas/piedra.jpg';
textures.leaf = new Image();  textures.leaf.src = 'Texturas/oja.png';
textures.log  = new Image();  textures.log.src  = 'Texturas/tronco.png';
textures.plank = new Image();
textures.plank.src = 'Texturas/tablon.png';
textures.particle_leaf = new Image();
textures.particle_leaf.src = 'Texturas/particle_leaf.png';

textures.crafting_table = new Image();
textures.crafting_table.src = 'Texturas/mesa_de_crafteo.png';

const crackTextures = [];
for(let i=1;i<=5;i++){
  const img = new Image();
  img.src = `Texturas/crack${i}.png`;
  crackTextures.push(img);
}

// Generaci√≥n de chunks
let chunks = {};
function generateChunk(chunkX){
  if(chunks[chunkX]) return chunks[chunkX];
  let surfaceHeight = ROWS-50;
  let currentHeight = surfaceHeight;
  let data = [];
  for(let x=0; x<CHUNK_SIZE; x++){
    let worldX = chunkX*CHUNK_SIZE + x;
    let change = Math.floor(Math.random()*3)-1;
    currentHeight += change;
    if(currentHeight<surfaceHeight-5) currentHeight = surfaceHeight-5;
    if(currentHeight>surfaceHeight+2) currentHeight = surfaceHeight+2;
    for(let y=0; y<ROWS; y++){
      if(!data[y]) data[y] = [];
      if(y<currentHeight) data[y][x] = null;
      else if(y===currentHeight) data[y][x]='grass';
      else if(y<currentHeight+3) data[y][x]='dirt';
      else data[y][x]='stone';
    }
  }
  chunks[chunkX] = {x: chunkX, data};
  return chunks[chunkX];
}
// === Capa de fondo (segunda capa) ===
let chunksBg = {};

function generateChunkBg(chunkX){
  if(chunksBg[chunkX]) return chunksBg[chunkX];

  let chunk = generateChunk(chunkX); 
  let data = [];

  for(let y=0; y<ROWS; y++){
    data[y] = [];
    for(let x=0; x<CHUNK_SIZE; x++){
      data[y][x] = chunk.data[y][x];
    }
  }

  // üå≥ Generaci√≥n de √°rboles
  for(let x=0; x<CHUNK_SIZE; x++){
    for(let y=0; y<ROWS; y++){
      if(data[y][x] === 'grass'){ 
        // 10% de probabilidad de √°rbol en ese bloque
        if(Math.random() < 0.1){
          generateTree({data}, x, y);
        }
      }
    }
  }

  chunksBg[chunkX] = {x: chunkX, data};
  return chunksBg[chunkX];
}


const invBtn = document.getElementById('inventory-btn');
const invPanel = document.getElementById('inventory-panel');

invBtn.addEventListener('click', () => {
  if (invPanel.style.display === 'none' || invPanel.style.display === '') {
    openInventoryNormal(); // siempre abre en modo normal
  } else {
    invPanel.style.display = 'none';
  }
});

// --- Controles de +cantidad- ---
document.getElementById("split-plus").onclick = ()=>{
  if (splitFrom !== null) {
    let max = 0;
    if (typeof splitFrom === "string" && splitFrom.startsWith("craft:")) {
      max = craftingGrid[parseInt(splitFrom.split(":")[1])]?.count || 0;
    } else {
      max = inventory[splitFrom]?.count || 0;
    }
    if (splitAmount < max) {
      splitAmount++;
      document.getElementById("split-count").textContent = splitAmount;
    }
  }
};

document.getElementById("split-minus").onclick = ()=>{
  if (splitAmount > 1) {
    splitAmount--;
    document.getElementById("split-count").textContent = splitAmount;
  }
};

const pauseBtn = document.getElementById('pause-btn');
const pauseMenu = document.getElementById('pause-menu');
const settingsPanel = document.getElementById('settings-panel');
const resumeBtn = document.getElementById('resume-btn');
const exitBtn = document.getElementById('exit-btn');
const settingsBtn = document.getElementById('settings-btn');
const closeSettings = document.getElementById('close-settings');
const blurBg = document.getElementById('blur-bg');

pauseBtn.addEventListener('click', () => {
  pauseMenu.style.display = 'flex';
  blurBg.style.display = 'block';
});

resumeBtn.addEventListener('click', () => {
  pauseMenu.style.display = 'none';
  settingsPanel.classList.remove('active');
  blurBg.style.display = 'none';
});

exitBtn.addEventListener('click', () => {
  // Funci√≥n para salir del juego
});

settingsBtn.addEventListener('click', () => {
  settingsPanel.classList.add('active');
});

closeSettings.addEventListener('click', () => {
  settingsPanel.classList.remove('active');
});

let inventory = new Array(27).fill(null); 
let selectedSlot = 0; // slot seleccionado en hotbar
function generateTree(chunkBg, localX, groundY){
  // altura del tronco entre 3 y 5
  let height = 3 + Math.floor(Math.random()*3);

  // tronco
  for(let h=0; h<height; h++){
    if(chunkBg.data[groundY-h-1]) // aseguramos que exista fila
      chunkBg.data[groundY-h-1][localX] = 'log';
  }

  // hojas (alrededor de la punta)
  let top = groundY - height;
  for(let dx=-2; dx<=2; dx++){
    for(let dy=-2; dy<=2; dy++){
      let dist = Math.abs(dx) + Math.abs(dy);
      if(dist <= 2){ // forma de cruz / redondeada
        let yy = top+dy;
        let xx = localX+dx;
        if(chunkBg.data[yy] && chunkBg.data[yy][xx]!==undefined && chunkBg.data[yy][xx]===null){
          chunkBg.data[yy][xx] = 'leaf';
        }
      }
    }
  }
}
let splitFrom = null;
let splitTo = null;
let splitAmount = 1;
let splitMax = 1;

// abrir panel
function openSplitPanel(fromIdx, toIdx, max){
  splitFrom = fromIdx;
  splitTo = toIdx;
  splitAmount = Math.ceil(max / 2);
  splitMax = max;
  document.getElementById("split-count").textContent = splitAmount;
  document.getElementById("split-panel").style.display = "block";
}

function closeSplitPanel(){
  document.getElementById("split-panel").style.display = "none";
  splitFrom = null;
  splitTo = null;
  splitAmount = 1;
}
// m√≠nimo (poner en 1)
document.getElementById("split-min").onclick = ()=>{
  if (splitFrom !== null) {
    splitAmount = 1;
    document.getElementById("split-count").textContent = splitAmount;
  }
};

// m√°ximo (poner en splitMax)
document.getElementById("split-max").onclick = ()=>{
  if (splitFrom !== null) {
    splitAmount = splitMax;
    document.getElementById("split-count").textContent = splitAmount;
  }
};

// confirmar con soporte inv/craft en ambos lados
document.getElementById("split-confirm").onclick = ()=>{
  if (splitFrom !== null && splitTo !== null) {
    let fromItem;

    // obtener origen
    if (typeof splitFrom === "string") {
      if (splitFrom.startsWith("craft:")) {
        fromItem = craftingGrid[parseInt(splitFrom.split(":")[1])];
      } else if (splitFrom.startsWith("craft3:")) {
        fromItem = craftingGrid3x3[parseInt(splitFrom.split(":")[1])];
      }
    } else {
      fromItem = inventory[splitFrom];
    }

    if (!fromItem) return;

    // stack a mover
    let moved = {
      type: fromItem.type,
      texture: fromItem.texture,
      count: splitAmount
    };

    // obtener destino
    let toItem;
    if (typeof splitTo === "string") {
      if (splitTo.startsWith("craft:")) {
        toItem = craftingGrid[parseInt(splitTo.split(":")[1])];
      } else if (splitTo.startsWith("craft3:")) {
        toItem = craftingGrid3x3[parseInt(splitTo.split(":")[1])];
      }
    } else {
      toItem = inventory[splitTo];
    }

    // --- l√≥gica ---
    if (!toItem) {
      // mover parcial
      if (typeof splitTo === "string") {
        if (splitTo.startsWith("craft:")) craftingGrid[parseInt(splitTo.split(":")[1])] = moved;
        else craftingGrid3x3[parseInt(splitTo.split(":")[1])] = moved;
      } else {
        inventory[splitTo] = moved;
      }
      fromItem.count -= splitAmount;
    }
    else if (toItem.type === moved.type) {
      // apilar
      toItem.count += moved.count;
      fromItem.count -= splitAmount;
    }
    else {
      // intercambio
      let temp = { ...toItem };

      if (typeof splitTo === "string") {
        if (splitTo.startsWith("craft:")) craftingGrid[parseInt(splitTo.split(":")[1])] = moved;
        else craftingGrid3x3[parseInt(splitTo.split(":")[1])] = moved;
      } else {
        inventory[splitTo] = moved;
      }

      if (typeof splitFrom === "string") {
        if (splitFrom.startsWith("craft:")) craftingGrid[parseInt(splitFrom.split(":")[1])] = temp;
        else craftingGrid3x3[parseInt(splitFrom.split(":")[1])] = temp;
      } else {
        inventory[splitFrom] = temp;
      }
    }

    // limpiar origen si queda vac√≠o
    if (fromItem.count <= 0) {
      if (typeof splitFrom === "string") {
        if (splitFrom.startsWith("craft:")) craftingGrid[parseInt(splitFrom.split(":")[1])] = null;
        else craftingGrid3x3[parseInt(splitFrom.split(":")[1])] = null;
      } else {
        inventory[splitFrom] = null;
      }
    }

    renderHotbar();
    renderInventoryGrid();
    if (usingCrafting3x3) {
      checkRecipes3x3();
      renderCrafting3x3();
    } else {
      checkRecipes();
      renderCrafting();
    }
  }

  closeSplitPanel();
};

function renderCrafting3x3(){
  const craftSlots = document.querySelectorAll('.craft-slot-3x3');
  craftSlots.forEach((slot, i)=>{
    slot.innerHTML='';
    let item = craftingGrid3x3[i];
    if(item){
      const img = document.createElement('img');
      img.src = item.texture;
      slot.appendChild(img);

      if(item.count > 1){
        const countDiv = document.createElement('div');
        countDiv.classList.add('count');
        countDiv.textContent = item.count;
        slot.appendChild(countDiv);
      }
    }
  });

  const resultSlot = document.getElementById('craft-result-3x3');
  resultSlot.innerHTML='';
  if(craftResult3x3){
    const img = document.createElement('img');
    img.src = craftResult3x3.texture;
    resultSlot.appendChild(img);

    if(craftResult3x3.count > 1){
      const countDiv = document.createElement('div');
      countDiv.classList.add('count');
      countDiv.textContent = craftResult3x3.count;
      resultSlot.appendChild(countDiv);
    }
  }
}

function closeSplitPanel(){
  document.getElementById("split-panel").style.display = "none";
  splitFrom = null;
  splitTo = null;
  splitAmount = 1;
}

document.getElementById("split-cancel").onclick = ()=>{
  closeSplitPanel();
};

function initInventorySelection() {
  const allSlots = document.querySelectorAll('#inventory-grid .slot');
  allSlots.forEach((slot, i) => {
    slot.dataset.type = 'inv';
    slot.dataset.index = i + 9; // Inventario grande ocupa 9‚Äì35
  });
}


let pickedSlot = null;

function enableTouchInventory() {
  const allSlots = document.querySelectorAll(
    '#inventory-grid .slot, #hotbar .slot, #hotbar-fixed .slot, #crafting-grid .slot, #crafting-grid-3x3 .slot'
  );

  allSlots.forEach((slot, i) => {
    // Detectar el tipo de slot
    if (slot.closest('#crafting-grid')) {
      slot.dataset.type = 'craft';
      slot.dataset.index = i % 4; // 0‚Äì3 para el 2x2
    } else if (slot.closest('#crafting-grid-3x3')) {
      slot.dataset.type = 'craft3';
      slot.dataset.index = i % 9; // 0‚Äì8 para el 3x3
    } else {
      slot.dataset.type = 'inv';
      slot.dataset.index = i; // inventario o hotbar
    }

    // Eventos de toque/click
    slot.onclick = () => {
      if (!pickedSlot) {
        // Primer toque ‚Üí seleccionar
        pickedSlot = slot;
        slot.classList.add('selected');
      } else if (pickedSlot === slot) {
        // Segundo toque en el mismo ‚Üí cancelar selecci√≥n
        slot.classList.remove('selected');
        pickedSlot = null;
      } else {
        // Segundo toque en otro slot ‚Üí mover/intercambiar
        const fromType = pickedSlot.dataset.type;
        const toType   = slot.dataset.type;
        const fromIdx  = parseInt(pickedSlot.dataset.index);
        const toIdx    = parseInt(slot.dataset.index);

        // üîπ Inventario ‚Üî Inventario
        if (fromType === 'inv' && toType === 'inv') {
          let temp = inventory[toIdx];
          inventory[toIdx] = inventory[fromIdx];
          inventory[fromIdx] = temp;
          renderHotbar();
          renderInventoryGrid();
        }

        // üîπ Inventario ‚Üí Crafting 2x2
        else if (fromType === 'inv' && toType === 'craft') {
          if (inventory[fromIdx]) {
            if (craftingGrid[toIdx]) {
              craftingGrid[toIdx].count += inventory[fromIdx].count;
            } else {
              craftingGrid[toIdx] = inventory[fromIdx];
            }
            inventory[fromIdx] = null;
            renderHotbar();
            renderInventoryGrid();
            renderCrafting();
            checkRecipes();
          }
        }

        // üîπ Crafting 2x2 ‚Üí Inventario
        else if (fromType === 'craft' && toType === 'inv') {
          if (craftingGrid[fromIdx]) {
            if (inventory[toIdx]) {
              inventory[toIdx].count += craftingGrid[fromIdx].count;
            } else {
              inventory[toIdx] = craftingGrid[fromIdx];
            }
            craftingGrid[fromIdx] = null;
            renderHotbar();
            renderInventoryGrid();
            renderCrafting();
            checkRecipes();
          }
        }

        // üîπ Inventario ‚Üí Crafting 3x3
        else if (fromType === 'inv' && toType === 'craft3') {
          if (inventory[fromIdx]) {
            if (craftingGrid3x3[toIdx]) {
              craftingGrid3x3[toIdx].count += inventory[fromIdx].count;
            } else {
              craftingGrid3x3[toIdx] = inventory[fromIdx];
            }
            inventory[fromIdx] = null;
            renderHotbar();
            renderInventoryGrid();
            renderCrafting3x3();
            checkRecipes3x3();
          }
        }

        // üîπ Crafting 3x3 ‚Üí Inventario
        else if (fromType === 'craft3' && toType === 'inv') {
          if (craftingGrid3x3[fromIdx]) {
            if (inventory[toIdx]) {
              inventory[toIdx].count += craftingGrid3x3[fromIdx].count;
            } else {
              inventory[toIdx] = craftingGrid3x3[fromIdx];
            }
            craftingGrid3x3[fromIdx] = null;
            renderHotbar();
            renderInventoryGrid();
            renderCrafting3x3();
            checkRecipes3x3();
          }
        }

        // limpiar selecci√≥n
        pickedSlot.classList.remove('selected');
        pickedSlot = null;
      }
    };
  });
}
// === SISTEMA DE PART√çCULAS ===
let particlesEnabled = true;
let particles = [];

class Particle {
  constructor(wx, wy, texture, life = 200) {
    // posiciones en coordenadas de mundo
    this.wx = wx + 0.5;  // centro horizontal del bloque
this.wy = wy + 0.5;  // centro vertical del bloque
                      // un poco debajo del bloque
    this.vx = (Math.random() - 0.5) * 0.02;      // viento lateral suave
    this.vy = Math.random() * 0.03 + 0.01;       // ca√≠da lenta
    this.life = life;
    this.size = BLOCK_SIZE * 0.15;               // ahora mucho m√°s peque√±as
    this.texture = texture;
    this.alpha = 1;
  }

  update() {
    this.wx += this.vx;
    this.wy += this.vy;
    this.life--;
    this.alpha = this.life / 200;
  }

  draw(ctx) {
    if (!this.texture.complete) return;

    // convertir coordenadas de mundo a pantalla
    const px = this.wx * BLOCK_SIZE - cameraX;
    const py = this.wy * BLOCK_SIZE - cameraY;

    // dibujar solo si est√°n en pantalla
    if (
      px + this.size < 0 || px > width ||
      py + this.size < 0 || py > height
    ) return;

    ctx.save();
    ctx.globalAlpha = this.alpha;
    ctx.drawImage(this.texture, px, py, this.size, this.size);
    ctx.restore();
  }
}

function spawnLeafParticles(wx, wy) {
  if (!particlesEnabled) return;
  // 1 o 2 hojitas m√°ximo por frame
  particles.push(new Particle(wx, wy, textures.particle_leaf, 200));
}

function updateParticles(ctx) {
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    p.update();
    p.draw(ctx);
    if (p.life <= 0) particles.splice(i, 1);
  }
}

const buttons = ['left', 'right', 'jump', 'down', 'inventory-btn'];

buttons.forEach(id => {
  const btn = document.getElementById(id);

  // al presionar
  btn.addEventListener('touchstart', () => btn.classList.add('active'));
  btn.addEventListener('mousedown', () => btn.classList.add('active'));

  // al soltar
  btn.addEventListener('touchend', () => btn.classList.remove('active'));
  btn.addEventListener('mouseup', () => btn.classList.remove('active'));
  btn.addEventListener('mouseleave', () => btn.classList.remove('active'));
});

function renderHotbar() {
  const hotbars = [document.getElementById('hotbar-fixed'), document.querySelector('#inventory-panel #hotbar')];
  hotbars.forEach(hb => {
    const slots = hb.querySelectorAll('.slot');
    slots.forEach((btn, i) => {
      btn.innerHTML=''; // limpiar
      if(i<inventory.length){
        const slotData = inventory[i];
        if(slotData){
          const img = document.createElement('img');
          img.src = slotData.texture;
          img.style.width='100%';
          img.style.height='100%';
          btn.appendChild(img);

          if(slotData.count > 1){
            const countDiv = document.createElement('div');
            countDiv.classList.add('count'); // ‚úÖ usa la clase pixelart
            countDiv.textContent = slotData.count;
            btn.appendChild(countDiv);
          }
        }
      }
      btn.classList.toggle('selected', i===selectedSlot);
      btn.dataset.index = i;
      btn.onclick = ()=>{ selectedSlot=i; renderHotbar(); };
    });
  });
}

function renderInventoryGrid() {
  const invSlots = document.querySelectorAll('#inventory-grid .slot');
  invSlots.forEach((btn, i) => {
    btn.innerHTML = ''; // limpiar
    const slotData = inventory[i];
    if(slotData){
      const img = document.createElement('img');
      img.src = slotData.texture;
      btn.appendChild(img);

      if(slotData.count > 1){
        const countDiv = document.createElement('div');
        countDiv.classList.add('count'); // ‚úÖ igual aqu√≠
        countDiv.textContent = slotData.count;
        btn.appendChild(countDiv);
      }
    }
  });
}

function getBlock(wx, wy){
  let chunkX = Math.floor(wx/CHUNK_SIZE);
  let localX = wx - chunkX*CHUNK_SIZE;
  let chunk = generateChunk(chunkX);
  if(chunk.data[wy] && chunk.data[wy][localX] !== undefined) return chunk.data[wy][localX];
  return null;
}

function setBlock(wx, wy, type){
  let chunkX = Math.floor(wx/CHUNK_SIZE);
  let localX = wx - chunkX*CHUNK_SIZE;
  let chunk = generateChunk(chunkX);
  if(chunk.data[wy]) chunk.data[wy][localX] = type;
}
// ==== Manejo de la capa 2 (fondo) ====
function getBlockBg(wx, wy){
  let chunkX = Math.floor(wx/CHUNK_SIZE);
  let localX = wx - chunkX*CHUNK_SIZE;
  let chunk = generateChunkBg(chunkX);
  if(chunk.data[wy] && chunk.data[wy][localX] !== undefined) return chunk.data[wy][localX];
  return null;
}

function setBlockBg(wx, wy, type){
  let chunkX = Math.floor(wx/CHUNK_SIZE);
  let localX = wx - chunkX*CHUNK_SIZE;
  let chunk = generateChunkBg(chunkX);
  if(chunk.data[wy]) chunk.data[wy][localX] = type;
}

function drawChunks() {
  let startChunk = Math.floor((cameraX / BLOCK_SIZE) / CHUNK_SIZE) - 1;
  let endChunk   = Math.floor((cameraX + width) / BLOCK_SIZE / CHUNK_SIZE) + 1;

  for (let cx = startChunk; cx <= endChunk; cx++) {
    // === Fondo (capa 2 m√°s oscuro) ===
    let chunkBg = generateChunkBg(cx);
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < CHUNK_SIZE; x++) {
        const type = chunkBg.data[y][x];
        if (!type) continue;

        const tex = textures[type];
        if (!tex.complete) continue;
if (type === 'leaf') {
  if (Math.random() < 0.002) { // baja probabilidad ‚Üí m√°s natural
    spawnLeafParticles(cx * CHUNK_SIZE + x, y + 1);
  }
}


        let screenX = (cx * CHUNK_SIZE + x) * BLOCK_SIZE - cameraX;
        let screenY = y * BLOCK_SIZE - cameraY;

        // üîπ Solo dibujar si est√° en pantalla
        if (
          screenX + BLOCK_SIZE < 0 || screenX > width ||
          screenY + BLOCK_SIZE < 0 || screenY > height
        ) continue;

        ctx.save();
        ctx.globalAlpha = 0.9; // m√°s oscuro
        ctx.drawImage(tex, screenX, screenY, BLOCK_SIZE, BLOCK_SIZE);
        ctx.fillStyle = "rgba(0,0,0,0.3)"; // sombra
        ctx.fillRect(screenX, screenY, BLOCK_SIZE, BLOCK_SIZE);
        ctx.restore();
      }
    }

    // === Frente (capa original interactuable) ===
    let chunk = generateChunk(cx);
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < CHUNK_SIZE; x++) {
        const type = chunk.data[y][x];
        if (!type) continue;

        const tex = textures[type];
        if (!tex.complete) continue;

        let screenX = (cx * CHUNK_SIZE + x) * BLOCK_SIZE - cameraX;
        let screenY = y * BLOCK_SIZE - cameraY;

        // üîπ Solo dibujar si est√° en pantalla
        if (
          screenX + BLOCK_SIZE < 0 || screenX > width ||
          screenY + BLOCK_SIZE < 0 || screenY > height
        ) continue;

        ctx.drawImage(tex, screenX, screenY, BLOCK_SIZE, BLOCK_SIZE);
      }
    }
  }
}


document.getElementById('left').addEventListener('touchstart', () => {
  leftPressed = true;
  lastDirection = {dx:-1, dy:0};
  player.facing = -1; // mirando izquierda
});

document.getElementById('right').addEventListener('touchstart', () => {
  rightPressed = true;
  lastDirection = {dx:1, dy:0};
  player.facing = 1; // mirando derecha
});

// === Texturas del jugador ===
const playerFrames = [];
for (let i = 1; i <= 4; i++) {
  const img = new Image();
  img.src = `Texturas/Cubs${i}.png`;
  playerFrames.push(img);
}
const crouchFrames = [];
for (let i = 1; i <= 4; i++) {
  const img = new Image();
  img.src = `Texturas/Cub_agachado${i}.png`;
  crouchFrames.push(img);
}

let crouching = false; // variable que indica si el jugador est√° agachado

let currentFrame = 0;
let frameTimer = 0;

// Cambiamos el jugador a usar texturas
let player = { 
  x:5, y:30, width:0.8, height:0.8, 
  vx:0, vy:0, onGround:false, 
  facing: 1 // 1 = derecha, -1 = izquierda
};

// === Dibujar jugador con animaci√≥n ===
function drawPlayer(dt) {
  const frames = crouching ? crouchFrames : playerFrames;

  // actualizar frame solo si se mueve y no solo por estar agachado
  if ((leftPressed || rightPressed)) {
    frameTimer += dt;
    if (frameTimer >= 0.2) { // 5 fps
      frameTimer = 0;
      currentFrame = (currentFrame + 1) % frames.length;
    }
  } else {
    currentFrame = 0; // si no se mueve, siempre frame inicial
  }

  const img = frames[currentFrame];
  if (!img.complete) return;

  const px = player.x*BLOCK_SIZE - cameraX;
  const py = player.y*BLOCK_SIZE - cameraY;
  const pw = player.width*BLOCK_SIZE;
  const ph = player.height*BLOCK_SIZE;

  ctx.save();
  if (player.facing === 1) {
    ctx.translate(px + pw, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(img, 0, py, pw, ph);
  } else {
    ctx.drawImage(img, px, py, pw, ph);
  }
  ctx.restore();
}


const gravity = 0.9;
const jumpPower = -15;
const playerSpeed = 0.12;
let speed = crouching ? playerSpeed * 0.4 : playerSpeed;

let cameraX=0, cameraY=0;

function isBlock(wx, wy){ return getBlock(Math.floor(wx), Math.floor(wy)) !== null; }

let collidingLeft=false, collidingRight=false, collidingTop=false, collidingBottom=false;
function movePlayer() {
  collidingLeft=false; collidingRight=false; collidingTop=false; collidingBottom=false;

  // --- L√≥gica de soporte al agacharse ---
  if(crouching && player.vx !== 0) {
    let ny = player.y + player.height + 0.01;
    let underCenter = isBlock(player.x + player.width/2, ny);

    if(player.vx < 0) { // izquierda
      let underLeft = isBlock(player.x, ny);
      if(!underLeft && !underCenter) player.vx = 0;
    } else if(player.vx > 0) { // derecha
      let underRight = isBlock(player.x + player.width, ny);
      if(!underRight && !underCenter) player.vx = 0;
    }
  }

  // --- Movimiento horizontal normal ---
  let nx = player.x + player.vx;
  if(player.vx < 0){
    if(!isBlock(nx, player.y) && !isBlock(nx + player.width, player.y) &&
       !isBlock(nx, player.y + player.height - 0.01) && !isBlock(nx + player.width, player.y + player.height - 0.01)) {
      player.x = nx;
    } else { 
      player.vx = 0; 
      collidingLeft = true; 
    }
  } else if(player.vx > 0){
    if(!isBlock(nx, player.y) && !isBlock(nx + player.width, player.y) &&
       !isBlock(nx, player.y + player.height - 0.01) && !isBlock(nx + player.width, player.y + player.height - 0.01)) {
      player.x = nx;
    } else { 
      player.vx = 0; 
      collidingRight = true; 
    }
  }

  // --- Movimiento vertical ---
  player.vy += gravity;
  let ny = player.y + player.vy / BLOCK_SIZE;
  player.onGround = false;

  if(player.vy > 0){ // cayendo
    if(!isBlock(player.x, ny + player.height) && !isBlock(player.x + player.width, ny + player.height)) {
      player.y = ny;
    } else {
      player.y = Math.floor(ny + player.height) - player.height;
      player.vy = 0; 
      player.onGround = true; 
      collidingBottom = true;
    }
  } else if(player.vy < 0){ // subiendo
    if(!isBlock(player.x, ny) && !isBlock(player.x + player.width, ny)) {
      player.y = ny;
    } else {
      player.vy = 0; 
      collidingTop = true;
    }
  }
}

function initInventorySlots() {
  // preparar √≠ndices manualmente
  document.querySelectorAll('#inventory-grid .slot').forEach((s,i)=>{
    s.dataset.index = i;       // 0‚Äì26
    s.dataset.type = "inv";
  });
  document.querySelectorAll('#hotbar .slot').forEach((s,i)=>{
    s.dataset.index = i;       // 0‚Äì8
    s.dataset.type = "inv";
  });
  document.querySelectorAll('#hotbar-fixed .slot').forEach((s,i)=>{
    s.dataset.index = i;       // 0‚Äì8
    s.dataset.type = "inv";
  });
  document.querySelectorAll('#crafting-grid .craft-slot').forEach((s,i)=>{
    s.dataset.index = i;       // 0‚Äì3
    s.dataset.type = "craft";
  });

  const allSlots = document.querySelectorAll('#inventory-grid .slot, #hotbar .slot, #hotbar-fixed .slot, #crafting-grid .craft-slot');

  allSlots.forEach((slot)=>{
    slot.onclick = ()=>{
      const clickedIndex = parseInt(slot.dataset.index);
      const clickedType  = slot.dataset.type; // "inv" o "craft"

      if(selectedSlot === null) {
        // primer click: seleccionar
        selectedSlot = { index: clickedIndex, type: clickedType };
        slot.classList.add('selected');
        console.log("Seleccionado:", selectedSlot);
      } else if(selectedSlot.index === clickedIndex && selectedSlot.type === clickedType) {
        // click en el mismo: deseleccionar
        slot.classList.remove('selected');
        console.log("Deseleccionado:", selectedSlot);
        selectedSlot = null;
      } else {
        // segundo click en otro slot
        let fromItem = selectedSlot.type === "inv" ? inventory[selectedSlot.index] : craftingGrid[selectedSlot.index];
        let toItem   = clickedType === "inv" ? inventory[clickedIndex] : craftingGrid[clickedIndex];

        console.log("Mover de", selectedSlot, "‚Üí", {index: clickedIndex, type: clickedType});
        console.log("Contenido origen:", fromItem);
        console.log("Contenido destino:", toItem);

        if (fromItem) {
  if (fromItem.count > 1) {
  // solo abrir split panel si el destino est√° vac√≠o o es del mismo tipo
  if (
    (selectedSlot.type === "inv" && clickedType === "inv") ||
    (selectedSlot.type === "inv" && clickedType === "craft")
  ) {
    if (!toItem || (toItem && toItem.type === fromItem.type)) {
      openSplitPanel(
        selectedSlot.index,
        (clickedType === "craft" ? "craft:" + clickedIndex : clickedIndex),
        fromItem.count
      );
      return; // salir aqu√≠
    }
  }
}

  // üîπ mover normal tambi√©n cuando count === 1
  if (!toItem) {
    if (clickedType === "inv") inventory[clickedIndex] = { ...fromItem };
    else craftingGrid[clickedIndex] = { ...fromItem };

    if (selectedSlot.type === "inv") inventory[selectedSlot.index] = null;
    else craftingGrid[selectedSlot.index] = null;

  } else {
  // --- Juntar si son del mismo tipo ---
  if (!toItem) {
  // destino vac√≠o ‚Üí mover
  if (clickedType === "inv") inventory[clickedIndex] = { ...fromItem };
  else craftingGrid[clickedIndex] = { ...fromItem };

  if (selectedSlot.type === "inv") inventory[selectedSlot.index] = null;
  else craftingGrid[selectedSlot.index] = null;
}

else if (toItem.type === fromItem.type) {
  // mismo tipo ‚Üí apilar
  toItem.count += fromItem.count;
  if (selectedSlot.type === "inv") inventory[selectedSlot.index] = null;
  else craftingGrid[selectedSlot.index] = null;
  console.log("Apilados:", fromItem.type, "‚Üí", toItem.count);
}

else {
  // distinto tipo ‚Üí intercambio
  // clonar para evitar referencias compartidas
let temp = { type: toItem.type, texture: toItem.texture, count: toItem.count };

if (clickedType === "inv") {
  inventory[clickedIndex] = { type: fromItem.type, texture: fromItem.texture, count: fromItem.count };
} else {
  craftingGrid[clickedIndex] = { type: fromItem.type, texture: fromItem.texture, count: fromItem.count };
}

if (selectedSlot.type === "inv") {
  inventory[selectedSlot.index] = temp;
} else {
  craftingGrid[selectedSlot.index] = temp;
}

  console.log("Intercambio:", fromItem, "<->", toItem);
}

}
}
        // limpiar selecci√≥n
        document.querySelectorAll('.slot.selected').forEach(s => s.classList.remove('selected'));
        selectedSlot = null;

        renderHotbar();
        renderInventoryGrid();
        renderCrafting();
        checkRecipes();
      }
    };
  });
}

initInventorySlots();
initCraftingSlots3x3(); // ‚Üê falta esta llamada

renderHotbar();
renderInventoryGrid();
let craftingGrid = new Array(4).fill(null);      // 2x2
let craftingGrid3x3 = new Array(9).fill(null);   // 3x3
let craftResult = null;
let craftResult3x3 = null;

let usingCrafting3x3 = false;
function openCraftingTable() {
  // mostrar inventario
  invPanel.style.display = 'block';

  // ocultar el crafteo 2x2
  document.getElementById('crafting-section').style.display = 'none';

  // mostrar el crafteo 3x3
  document.getElementById('crafting-section-3x3').style.display = 'flex';

  // marcar que estamos usando el 3x3
  usingCrafting3x3 = true;
}
function openInventoryNormal() {
  invPanel.style.display = 'block';

  // mostrar 2x2
  document.getElementById('crafting-section').style.display = 'flex';

  // ocultar 3x3
  document.getElementById('crafting-section-3x3').style.display = 'none';

  usingCrafting3x3 = false;
}

function initCraftingSlots3x3(){
  const craftSlots = document.querySelectorAll('.craft-slot-3x3');
  craftSlots.forEach((slot, i)=>{
    slot.dataset.index = i;
    slot.onclick = ()=>{
      if(selectedSlot && selectedSlot.type === "inv"){
        let invItem = inventory[selectedSlot.index];
        if(invItem){
          if(invItem.count > 1){
            openSplitPanel(selectedSlot.index, "craft3:"+i, invItem.count);
          } else {
            craftingGrid3x3[i] = {
              type: invItem.type,
              texture: invItem.texture,
              count: 1
            };
            invItem.count--;
            if(invItem.count <= 0) inventory[selectedSlot.index] = null;

            renderHotbar();
            renderInventoryGrid();
            renderCrafting3x3();
            checkRecipes3x3();
          }
        }
      }
    };
  });

  document.getElementById('craft-result-3x3').onclick = ()=>{
    if(craftResult3x3){
      addItem(craftResult3x3.type, craftResult3x3.count);
      craftingGrid3x3 = new Array(9).fill(null);
      craftResult3x3 = null;
      renderCrafting3x3();
      renderHotbar();
      renderInventoryGrid();
    }
  };
}

function initCraftingSlots(){
  const craftSlots = document.querySelectorAll('.craft-slot');
  craftSlots.forEach((slot, i)=>{
    slot.dataset.index = i;
    slot.onclick = ()=>{
      if(selectedSlot && selectedSlot.type === "inv"){
        let invItem = inventory[selectedSlot.index];
        if(invItem){
          // si hay m√°s de 1, abrir panel de dividir
          if(invItem.count > 1){
            openSplitPanel(selectedSlot.index, "craft:"+i, invItem.count);
          } else {
            // mover solo 1 al crafteo
            craftingGrid[i] = {
              type: invItem.type,
              texture: invItem.texture,
              count: 1
            };

            // restar del inventario
            invItem.count--;
            if(invItem.count <= 0){
              inventory[selectedSlot.index] = null;
            }

            renderHotbar();
            renderInventoryGrid();
            renderCrafting();
            checkRecipes();
          }
        }
      }
    };
  });

  document.getElementById('craft-result').onclick = ()=>{
    if(craftResult){
      addItem(craftResult.type, craftResult.count);
      craftingGrid = new Array(4).fill(null);
      craftResult = null;
      renderCrafting();
      renderHotbar();
      renderInventoryGrid();
    }
  };


  document.getElementById('craft-result').onclick = ()=>{
  if(craftResult){
    addItem(craftResult.type, craftResult.count);
    craftingGrid = new Array(4).fill(null);
    craftResult = null;
    renderCrafting();
    renderHotbar();
    renderInventoryGrid();
  }
};
}
function renderCrafting(){
  const craftSlots = document.querySelectorAll('.craft-slot');
  craftSlots.forEach((slot, i)=>{
    slot.innerHTML='';
    let item = craftingGrid[i];
    if(item){
      const img = document.createElement('img');
      img.src = item.texture;
      slot.appendChild(img);
    }
  });

  // resultado
  const resultSlot = document.getElementById('craft-result');
  resultSlot.innerHTML='';
  if(craftResult){
    const img = document.createElement('img');
    img.src = craftResult.texture;
    resultSlot.appendChild(img);
  }
}
if(craftResult){
  const img = document.createElement('img');
  img.src = craftResult.texture;
  resultSlot.appendChild(img);

  if(craftResult.count > 1){
    const countDiv = document.createElement('div');
    countDiv.style.position = 'absolute';
    countDiv.style.bottom = '2px';
    countDiv.style.right = '2px';
    countDiv.style.color = 'white';
    countDiv.style.fontSize = '12px';
    countDiv.textContent = craftResult.count;
    resultSlot.appendChild(countDiv);
  }
}


// === RECETAS DE PLANK EN 3x3 ===
// === RECETAS DE MESA DE CRAFTEO EN 3x3 ===
const recipes3x3 = [
  // --- tus 9 recetas de LOG -> PLANK ---
  {
    pattern: [
      'log', null, null,
      null,  null, null,
      null,  null, null
    ],
    result: {type:'plank', texture:'Texturas/tablon.png', baseCount:4}
  },
  {
    pattern: [
      null, 'log', null,
      null, null, null,
      null, null, null
    ],
    result: {type:'plank', texture:'Texturas/tablon.png', baseCount:4}
  },
  {
    pattern: [
      null, null, 'log',
      null, null, null,
      null, null, null
    ],
    result: {type:'plank', texture:'Texturas/tablon.png', baseCount:4}
  },
  {
    pattern: [
      null, null, null,
      'log', null, null,
      null, null, null
    ],
    result: {type:'plank', texture:'Texturas/tablon.png', baseCount:4}
  },
  {
    pattern: [
      null, null, null,
      null, 'log', null,
      null, null, null
    ],
    result: {type:'plank', texture:'Texturas/tablon.png', baseCount:4}
  },
  {
    pattern: [
      null, null, null,
      null, null, 'log',
      null, null, null
    ],
    result: {type:'plank', texture:'Texturas/tablon.png', baseCount:4}
  },
  {
    pattern: [
      null, null, null,
      null, null, null,
      'log', null, null
    ],
    result: {type:'plank', texture:'Texturas/tablon.png', baseCount:4}
  },
  {
    pattern: [
      null, null, null,
      null, null, null,
      null, 'log', null
    ],
    result: {type:'plank', texture:'Texturas/tablon.png', baseCount:4}
  },
  {
    pattern: [
      null, null, null,
      null, null, null,
      null, null, 'log'
    ],
    result: {type:'plank', texture:'Texturas/tablon.png', baseCount:4}
  },

  // --- ahora las 5 recetas de PLANK -> MESA DE CRAFTEO ---
  // esquina superior izquierda
  {
    pattern: [
      'plank','plank', null,
      'plank','plank', null,
      null,   null,   null
    ],
    result: {type:'crafting_table', texture:'Texturas/mesa_de_crafteo.png', baseCount:1}
  },
  // esquina superior derecha
  {
    pattern: [
      null, 'plank','plank',
      null, 'plank','plank',
      null, null,   null
    ],
    result: {type:'crafting_table', texture:'Texturas/mesa_de_crafteo.png', baseCount:1}
  },
  // esquina inferior izquierda
  {
    pattern: [
      null,   null,   null,
      'plank','plank', null,
      'plank','plank', null
    ],
    result: {type:'crafting_table', texture:'Texturas/mesa_de_crafteo.png', baseCount:1}
  },
  // esquina inferior derecha
  {
    pattern: [
      null,   null,   null,
      null, 'plank','plank',
      null, 'plank','plank'
    ],
    result: {type:'crafting_table', texture:'Texturas/mesa_de_crafteo.png', baseCount:1}
  },
  // === NUEVAS RECETAS ===

  {
    pattern: [
      'plank', null,  null,
      'plank', null,  null,
      null,    null,  null
    ],
    result: {type:'stick', texture:'Texturas/palo.png', baseCount:4}
  },
// Palos: 2 tablones en vertical ‚Üí 4 palos

// üî∏ Columna 1
// Fila 1‚Äì2
{
  pattern: [
    'plank', null,  null,
    'plank', null,  null,
    null,    null,  null
  ],
  result: {type:'stick', texture:'Texturas/palo.png', baseCount:4}
},
// Fila 2‚Äì3
{
  pattern: [
    null,    null,  null,
    'plank', null,  null,
    'plank', null,  null
  ],
  result: {type:'stick', texture:'Texturas/palo.png', baseCount:4}
},

// üî∏ Columna 2
// Fila 1‚Äì2
{
  pattern: [
    null, 'plank', null,
    null, 'plank', null,
    null, null,   null
  ],
  result: {type:'stick', texture:'Texturas/palo.png', baseCount:4}
},
// Fila 2‚Äì3
{
  pattern: [
    null, null,   null,
    null, 'plank', null,
    null, 'plank', null
  ],
  result: {type:'stick', texture:'Texturas/palo.png', baseCount:4}
},

// üî∏ Columna 3
// Fila 1‚Äì2
{
  pattern: [
    null,  null, 'plank',
    null,  null, 'plank',
    null,  null, null
  ],
  result: {type:'stick', texture:'Texturas/palo.png', baseCount:4}
},
// Fila 2‚Äì3
{
  pattern: [
    null, null,  null,
    null, null, 'plank',
    null, null, 'plank'
  ],
  result: {type:'stick', texture:'Texturas/palo.png', baseCount:4}
},

  // Pico de madera: 3 tablones arriba + 2 palos en el centro ‚Üì
  {
    pattern: [
      'plank','plank','plank',
      null,  'stick', null,
      null,  'stick', null
    ],
    result: {type:'wood_pickaxe', texture:'Texturas/pico_madera.png', baseCount:1}
  },

  // Pico de piedra: 3 piedras arriba + 2 palos en el centro ‚Üì
  {
    pattern: [
      'stone','stone','stone',
      null,   'stick', null,
      null,   'stick', null
    ],
    result: {type:'stone_pickaxe', texture:'Texturas/pico_piedra.png', baseCount:1}
  },


  // centro
  {
    pattern: [
      null,   null,   null,
      null, 'plank','plank',
      null, 'plank','plank'
    ],
    result: {type:'crafting_table', texture:'Texturas/mesa_de_crafteo.png', baseCount:1}
  }
];

const recipes = [
  {
    pattern: ['log', null,
              null, null],
    result: {type:'plank', texture:'Texturas/tablon.png', baseCount:4}
  },
  {
    pattern: ['plank','plank',
              'plank','plank'],
    result: {type:'crafting_table', texture:'Texturas/mesa_de_crafteo.png', baseCount:1}
  },
  {
    pattern: ['plank',null,
              'plank',null],
    result: {type:'stick', texture:'Texturas/palo.png', baseCount:4}
  },
  {
    pattern: [null,'plank',
              null,'plank'],
    result: {type:'stick', texture:'Texturas/palo.png', baseCount:4}
  },
  {
    pattern: [null,'log',
              null,null],
    result: {type:'plank', texture:'Texturas/tablon.png', baseCount:4}
  },
  {
    pattern: [null,null,
              'log',null],
    result: {type:'plank', texture:'Texturas/tablon.png', baseCount:4}
  },
  {
    pattern: [null,null,
              null,'log'],
    result: {type:'plank', texture:'Texturas/tablon.png', baseCount:4}
  }
];

function checkRecipes3x3(){
  craftResult3x3 = null;

  for(let recipe of recipes3x3){
    let match = true;
    let materialCount = 0;

    for(let i=0;i<9;i++){
      let need = recipe.pattern[i];
      let slot = craftingGrid3x3[i];
      let has = slot ? slot.type : null;

      if(need !== has){
        match = false;
        break;
      }
      if(slot) materialCount += slot.count;
    }

    if(match){
      const required = recipe.pattern.filter(x=>x!==null).length;
      let amount = Math.floor(materialCount / required) * recipe.result.baseCount;
      if(amount > 0){
        craftResult3x3 = {...recipe.result, count: amount};
      }
      break;
    }
  }
  renderCrafting3x3();
}


// === VERIFICAR RECETAS ===
function checkRecipes(){
  craftResult = null;

  for(let recipe of recipes){
    let match = true;
    let materialCount = 0;

    for(let i=0;i<4;i++){
      let need = recipe.pattern[i];
      let slot = craftingGrid[i];
      let has = slot ? slot.type : null;

      if(need !== has){
        match = false;
        break;
      }
      if(slot) {
        materialCount += slot.count;
      }
    }

    if(match){
      const required = recipe.pattern.filter(x=>x!==null).length; // materiales por receta
      let amount = Math.floor(materialCount / required) * recipe.result.baseCount;
      if(amount > 0){
        craftResult = {...recipe.result, count: amount};
      }
      break;
    }
  }

  renderCrafting();
}

const placeableBlocks = [
  'stone','dirt','grass','log','plank','crafting_table'
];

// === MOSTRAR CRAFTEO ===
function renderCrafting(){
  const craftSlots = document.querySelectorAll('.craft-slot');
  craftSlots.forEach((slot, i)=>{
    slot.innerHTML='';
    let item = craftingGrid[i];
    if(item){
      const img = document.createElement('img');
      img.src = item.texture;
      slot.appendChild(img);

      if(item.count > 1){
        const countDiv = document.createElement('div');
        countDiv.style.position = 'absolute';
        countDiv.style.bottom = '2px';
        countDiv.style.right = '2px';
        countDiv.style.color = 'white';
        countDiv.style.fontSize = '12px';
        countDiv.textContent = item.count;
        slot.appendChild(countDiv);
      }
    }
  });

  // resultado
  const resultSlot = document.getElementById('craft-result');
  resultSlot.innerHTML='';
  if(craftResult){
    const img = document.createElement('img');
    img.src = craftResult.texture;
    resultSlot.appendChild(img);

    if(craftResult.count > 1){
      const countDiv = document.createElement('div');
      countDiv.style.position = 'absolute';
      countDiv.style.bottom = '2px';
      countDiv.style.right = '2px';
      countDiv.style.color = 'white';
      countDiv.style.fontSize = '12px';
      countDiv.textContent = craftResult.count;
      resultSlot.appendChild(countDiv);
    }
  }
}

// === CLICK EN RESULTADO ===
document.getElementById('craft-result').onclick = ()=>{
  if(craftResult){
    addItem(craftResult.type, craftResult.count);
    craftingGrid = new Array(4).fill(null);
    craftResult = null;
    renderCrafting();
    renderHotbar();
    renderInventoryGrid();
  }
};

let lastDirection = {dx:1, dy:0};

// Variables de estado de los botones
let leftPressed = false, rightPressed = false, jumpPressed = false, downPressed = false;

// Controles t√°ctiles y actualizaci√≥n de direcci√≥n
document.getElementById('left').addEventListener('touchstart', () => {
  leftPressed = true;
  lastDirection = {dx:-1, dy:0};
});
document.getElementById('left').addEventListener('touchend', () => leftPressed=false);

document.getElementById('right').addEventListener('touchstart', () => {
  rightPressed = true;
  lastDirection = {dx:1, dy:0};
});
document.getElementById('right').addEventListener('touchend', () => rightPressed=false);

document.getElementById('jump').addEventListener('touchstart', () => {
  jumpPressed = true;
  lastDirection = {dx:0, dy:-1}; // arriba
});
document.getElementById('jump').addEventListener('touchend', () => jumpPressed=false);

document.getElementById('down').addEventListener('touchstart', () => {
  if (breakMode) {
    lastDirection = {dx:0, dy:1}; // abajo
  } else {
    crouching = !crouching; // agacharse normal
  }
  downPressed = true;
});
document.getElementById('down').addEventListener('touchend', () => downPressed=false);

document.getElementById('down').addEventListener('touchend', () => {
  downPressed = false;
});

// Bot√≥n PRI
// === Botones PRI y BG ===
let breakMode = false;     // capa 1
let breakBgMode = false;   // capa 2

const priBtn = document.getElementById('pri-btn');
const priBgBtn = document.getElementById('pri-bg-btn');

// PRI (frente)
priBtn.addEventListener('touchstart', () => {
  breakMode = !breakMode;
  if(breakMode){
    priBtn.classList.add('active');
    breakBgMode = false;
    priBgBtn.classList.remove('active');
  } else {
    priBtn.classList.remove('active');
    stopBreaking();
  }
});

// BG (fondo)
priBgBtn.addEventListener('touchstart', () => {
  breakBgMode = !breakBgMode;
  if(breakBgMode){
    priBgBtn.classList.add('active');
    breakMode = false;
    priBtn.classList.remove('active');
  } else {
    priBgBtn.classList.remove('active');
    stopBreaking();
  }
});

// Datos de bloques
const blockData = {
  'stone': {time:30},
  'dirt': {time:5},
  'grass': {time:5},
  'log': {time:15},
  'leaf': {time:0.5},
  'plank': {time:10},          // tablones ‚Üí intermedio
  'crafting_table': {time:20}  // mesa de crafteo ‚Üí m√°s resistente
};

// Romper bloques
let breaking = {active:false, wx:0, wy:0, progress:0, time:0, type:null, delay:0};

function handleBreaking(dt){
  if((!breakMode && !breakBgMode) || !lastDirection) { stopBreaking(); return; }

  // Calculamos bloque objetivo seg√∫n √∫ltima direcci√≥n
  let wx, wy;
  if(lastDirection.dy > 0){
    wx = Math.floor(player.x + player.width/2);
    wy = Math.floor(player.y + player.height);
  } else if(lastDirection.dy < 0){
    wx = Math.floor(player.x + player.width/2);
    wy = Math.floor(player.y - 1);
  } else {
    wx = Math.floor(player.x + lastDirection.dx);
    wy = Math.floor(player.y + player.height/2);
  }

  // --- Diferencia entre capa 1 y capa 2 ---
  let type = breakMode ? getBlock(wx, wy) : getBlockBg(wx, wy);

  if(!type) { stopBreaking(); return; }

  if(!breaking.active || breaking.wx!==wx || breaking.wy!==wy){
    breaking.active = true;
    breaking.wx = wx;
    breaking.wy = wy;
    breaking.type = type;
    breaking.time = 0;
    breaking.progress = 0;
    breaking.delay = 0;
  }

  breaking.delay += dt;
  if(breaking.delay >= 0.5){
    updateBreaking(dt);
  }
}


function updateBreaking(dt){
  if(!breaking.active) return;

  let maxTime = 5;
  if(blockData[breaking.type]) maxTime = blockData[breaking.type].time;

  breaking.time += dt;
  breaking.progress = Math.min(breaking.time/maxTime,1);

  if(breaking.progress>=1){
    if(breakMode){
      // rompe capa 1
      setBlock(breaking.wx, breaking.wy, null);
      addItem(breaking.type);
    } 
    else if(breakBgMode){
      // rompe capa 2
      setBlockBg(breaking.wx, breaking.wy, null);
      addItem(breaking.type);   // ‚úÖ ahora s√≠ agrega al inventario
    }

    stopBreaking();
  }
}

function stopBreaking(){
  breaking.active=false;
  breaking.wx=0; breaking.wy=0; breaking.type=null; breaking.time=0; breaking.progress=0; breaking.delay=0;
}

function drawBreaking(){
  if(breaking.active && breaking.type){
    let stage = Math.floor(breaking.progress*4);
    let img = crackTextures[stage];
    if(img.complete) ctx.drawImage(img, breaking.wx*BLOCK_SIZE-cameraX, breaking.wy*BLOCK_SIZE-cameraY, BLOCK_SIZE, BLOCK_SIZE);
  }
}
function addItem(type, amount = 1){
  const textureMap = {
    stone: 'Texturas/piedra.jpg',
    dirt: 'Texturas/tierra.jpg',
    grass: 'Texturas/cesped_parte_costado.jpg',
    leaf: 'Texturas/oja.png',
    log:  'Texturas/tronco.png',
    plank: 'Texturas/tablon.png',
    crafting_table: 'Texturas/mesa_de_crafteo.png'
  };

  const itemTextures = {
    stick: 'Texturas/palo.png',
    wood_pickaxe: 'Texturas/pico_madera.png',
    stone_pickaxe: 'Texturas/pico_piedra.png'
  };

  // buscar textura en bloques o en √≠tems
  let tex = textureMap[type] || itemTextures[type];
  if(!tex) return; // si no existe, no lo a√±ade

  // Buscar stack existente
  let slot = inventory.find(s => s && s.type===type);
  if(slot){ 
    slot.count += amount; 
    renderHotbar(); 
    renderInventoryGrid();
    return; 
  }

  // Buscar primer slot vac√≠o
  let emptyIndex = inventory.findIndex(s=>!s);
  if(emptyIndex>=0){ 
    inventory[emptyIndex] = {type, texture:tex, count:amount}; 
    renderHotbar(); 
    renderInventoryGrid();
  }
  else console.log('Inventario lleno');
}

//real//
// Touch para colocar bloque
canvas.addEventListener('touchstart', e=>{
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const cx = touch.clientX - rect.left;
  const cy = touch.clientY - rect.top;

  const wx = Math.floor((cx + cameraX)/BLOCK_SIZE);
  const wy = Math.floor((cy + cameraY)/BLOCK_SIZE);

  // si toca una mesa de crafteo en cualquier capa ‚Üí abrir crafting
  if(getBlock(wx, wy)==='crafting_table' || getBlockBg(wx, wy)==='crafting_table'){
    openCraftingTable();
    return;
  }

  placeBlock(wx, wy);
});

//check 1//
const nonPlaceable = ['stick','wood_pickaxe','stone_pickaxe'];

function placeBlock(wx, wy){
  const slot = inventory[selectedSlot];
  if(!slot) return;

  // üö´ No permitir colocar objetos no colocables
  if(nonPlaceable.includes(slot.type)) return;

  // 1Ô∏è‚É£ Primero capa de fondo
  if(getBlockBg(wx, wy) === null){
    setBlockBg(wx, wy, slot.type);
  }
  // 2Ô∏è‚É£ Si ya hay en fondo, colocar en frente
  else if(getBlock(wx, wy) === null){
    setBlock(wx, wy, slot.type);
  }
  // 3Ô∏è‚É£ Si ambas ocupadas ‚Üí nada
  else {
    return;
  }

  // ‚úÖ consumir solo 1 bloque
  slot.count--;
  if(slot.count <= 0) inventory[selectedSlot] = null;

  renderHotbar();
  renderInventoryGrid();
}

// Touch para colocar bloque

// Juego principal
let lastTime = performance.now();
function gameLoop(time){
  let dt = (time - lastTime)/1000;
  lastTime = time;

  ctx.clearRect(0,0,width,height);

// velocidad din√°mica: normal o agachado
let speed = crouching ? playerSpeed * 0.4 : playerSpeed;

player.vx = 0;
if (leftPressed) player.vx = -speed;
if (rightPressed) player.vx = speed;
if (particlesEnabled) {
  updateParticles(ctx);
}

if (jumpPressed && player.onGround) player.vy = jumpPower;

  movePlayer();
  cameraX = player.x*BLOCK_SIZE - width/2 + BLOCK_SIZE/2;
  cameraY = player.y*BLOCK_SIZE - height/2 + BLOCK_SIZE/2;

  handleBreaking(dt);
  updateBreaking(dt);

  drawChunks();
  drawBreaking();

  drawPlayer(dt);

  requestAnimationFrame(gameLoop);
}
gameLoop();
</script>
</body>
</html>
