<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CUBOX</title>
<style>
html, body { margin:0; padding:0; overflow:hidden; }
canvas { display:block; background:#87CEEB; }

/* Contenedor de controles */
/* Contenedor normal de controles */
#controls {
  position: fixed;
  bottom: 10px;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between;
  padding: 0 20px;
  pointer-events: none; /* ← importante, evita que tape clicks */
}

.left-controls,
.right-controls {
  display: flex;
  gap: 10px;
  pointer-events: auto; /* ← los hijos sí reciben toques */
}


/* Botón PRI separado y más arriba */
#pri-container {
  position: fixed;
  right: 10px;
  bottom: 100px; /* más arriba que los otros botones */
  z-index: 10;
}

/* Estilo común para todos los botones */
.control-btn {
  width: 64px;
  height: 40px;
  background-color: rgba(100, 100, 100, 0.5);
  border: 2px solid white;
  color: white;
  text-align: center;
  line-height: 40px;
  font-weight: bold;
  border-radius: 8px;
  user-select: none;
  touch-action: none;
}

/* PRI activo */
#pri-btn.active {
  background-color: rgba(200, 50, 50, 0.7);
}

#hotbar-fixed {
  position: fixed;
  bottom: 15px;           /* posición un poco más arriba */
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 5px;               /* espacio moderado entre slots */
  background: rgba(0,0,0,0.6);
  padding: 5px;           /* padding moderado */
  border-radius: 6px;     /* bordes redondeados moderados */
  z-index: 20;
}

#hotbar-fixed .slot {
  width: 30px;            /* tamaño de slots más cómodo */
  height: 30px;
}
.control-btn.active {
  outline: 3px solid yellow; /* borde sin afectar tamaño */
  border: 2px solid white;   /* borde original se mantiene */
  box-shadow: none;
  transform: none;
}



#inventory-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(30,30,30,0.9);
  padding: 15px;
  border-radius: 10px;
  display: none; /* lo puedes mostrar/ocultar con JS */
  z-index: 30;
}

#inventory-grid {
  display: grid;
  grid-template-columns: repeat(9, 1fr);
  gap: 5px;
  margin-bottom: 10px;
}

#hotbar {
  display: flex;
  gap: 2px;
  justify-content: center;
}

.slot {
  width: 45px;
  height: 45px;
  background: #ccc;
  border: 2px solid #555;
  border-radius: 4px;
  cursor: pointer;
  outline: none;
  -webkit-tap-highlight-color: transparent;
  position: relative; /* ← importante para el contador */
  overflow: hidden;
}

.slot div.count {
  position: absolute;
  bottom: 2px;
  right: 2px;
  color: white;
  font-size: 12px;
  font-weight: bold;
  pointer-events: none;
}

.slot.selected {
  border: 2px solid yellow;
  box-shadow: none; /* quitamos el efecto interno */
}
.slot img {
  width: 100%;
  height: 100%;
  object-fit: contain; /* mantiene proporción sin deformar */
  pointer-events: none; /* para que el click vaya al slot */
}

#inventory-btn {
  position: fixed;
  left: 10px;
  bottom: 100px;
  width: 60px;
  height: 40px;
  background-color: rgba(100,100,100,0.6);
  color: white;
  border: 2px solid white;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  z-index: 40;
  touch-action: manipulation;
}

</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<!-- Hotbar fija en pantalla -->
<!-- Botón para abrir inventario -->
<button id="inventory-btn">INV</button>

<div id="hotbar-fixed">
  <button class="slot"></button><button class="slot"></button><button class="slot"></button>
  <button class="slot"></button><button class="slot"></button><button class="slot"></button>
  <button class="slot"></button><button class="slot"></button><button class="slot"></button>
</div>

<!-- Inventario completo -->
<div id="inventory-panel">
  <div id="inventory-grid">
    <!-- 27 slots (9x3) -->
    <button class="slot"></button><button class="slot"></button><button class="slot"></button>
    <button class="slot"></button><button class="slot"></button><button class="slot"></button>
    <button class="slot"></button><button class="slot"></button><button class="slot"></button>

    <button class="slot"></button><button class="slot"></button><button class="slot"></button>
    <button class="slot"></button><button class="slot"></button><button class="slot"></button>
    <button class="slot"></button><button class="slot"></button><button class="slot"></button>

    <button class="slot"></button><button class="slot"></button><button class="slot"></button>
    <button class="slot"></button><button class="slot"></button><button class="slot"></button>
    <button class="slot"></button><button class="slot"></button><button class="slot"></button>
  </div>

  <!-- Hotbar dentro del inventario -->
  <div id="hotbar">
    <button class="slot"></button><button class="slot"></button><button class="slot"></button>
    <button class="slot"></button><button class="slot"></button><button class="slot"></button>
    <button class="slot"></button><button class="slot"></button><button class="slot"></button>
  </div>
</div>


<div id="controls">
  <div class="left-controls">
    <div class="control-btn" id="left">◀</div>
    <div class="control-btn" id="right">▶</div>
  </div>
  <div class="right-controls">
    <div class="control-btn" id="down">▼</div>
    <div class="control-btn" id="jump">▲</div>
  </div>
</div>

<div id="pri-container">
  <div class="control-btn" id="pri-btn">PRI</div>
</div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width = window.innerWidth;
let height = window.innerHeight;

const scale = window.devicePixelRatio || 1; // detecta si es 2K, 4K, etc.
canvas.width = width * scale;
canvas.height = height * scale;
canvas.style.width = width + "px";
canvas.style.height = height + "px";
ctx.scale(scale, scale);


let BLOCK_SIZE = 100; // valor inicial

function setZoom(level) {
  BLOCK_SIZE = level; // ejemplo: setZoom(80) → más cerca
}

const ROWS = 100;
const CHUNK_SIZE = 20;

// Texturas
const textures = {};
textures.grass = new Image(); textures.grass.src = 'Texturas/cesped_parte_costado.jpg';
textures.dirt = new Image(); textures.dirt.src = 'Texturas/tierra.jpg';
textures.stone = new Image(); textures.stone.src = 'Texturas/piedra.jpg';

const crackTextures = [];
for(let i=1;i<=5;i++){
  const img = new Image();
  img.src = `Texturas/crack${i}.png`;
  crackTextures.push(img);
}

// Generación de chunks
let chunks = {};
function generateChunk(chunkX){
  if(chunks[chunkX]) return chunks[chunkX];
  let surfaceHeight = ROWS-50;
  let currentHeight = surfaceHeight;
  let data = [];
  for(let x=0; x<CHUNK_SIZE; x++){
    let worldX = chunkX*CHUNK_SIZE + x;
    let change = Math.floor(Math.random()*3)-1;
    currentHeight += change;
    if(currentHeight<surfaceHeight-5) currentHeight = surfaceHeight-5;
    if(currentHeight>surfaceHeight+2) currentHeight = surfaceHeight+2;
    for(let y=0; y<ROWS; y++){
      if(!data[y]) data[y] = [];
      if(y<currentHeight) data[y][x] = null;
      else if(y===currentHeight) data[y][x]='grass';
      else if(y<currentHeight+3) data[y][x]='dirt';
      else data[y][x]='stone';
    }
  }
  chunks[chunkX] = {x: chunkX, data};
  return chunks[chunkX];
}
const invBtn = document.getElementById('inventory-btn');
const invPanel = document.getElementById('inventory-panel');

invBtn.addEventListener('click', () => {
  if (invPanel.style.display === 'none' || invPanel.style.display === '') {
    invPanel.style.display = 'block'; // abrir
  } else {
    invPanel.style.display = 'none';  // cerrar
  }
});


let inventory = new Array(27).fill(null); 
let selectedSlot = 0; // slot seleccionado en hotbar

function initInventorySelection() {
  const allSlots = document.querySelectorAll('.slot');

  allSlots.forEach((slot, i) => {
    slot.dataset.index = i;
    slot.addEventListener('click', () => {
      if (selectedSlot !== null) {
        allSlots[selectedSlot].classList.remove('selected');
      }
      selectedSlot = i;
      slot.classList.add('selected');
      console.log('Slot seleccionado:', i);
    });
  });
}
const buttons = ['left', 'right', 'jump', 'down', 'inventory-btn'];

buttons.forEach(id => {
  const btn = document.getElementById(id);

  // al presionar
  btn.addEventListener('touchstart', () => btn.classList.add('active'));
  btn.addEventListener('mousedown', () => btn.classList.add('active'));

  // al soltar
  btn.addEventListener('touchend', () => btn.classList.remove('active'));
  btn.addEventListener('mouseup', () => btn.classList.remove('active'));
  btn.addEventListener('mouseleave', () => btn.classList.remove('active'));
});

function renderHotbar() {
  const hotbars = [document.getElementById('hotbar-fixed'), document.querySelector('#inventory-panel #hotbar')];
  hotbars.forEach(hb => {
    const slots = hb.querySelectorAll('.slot');
    slots.forEach((btn, i) => {
      btn.innerHTML=''; // limpiar
      if(i<inventory.length){
        const slotData = inventory[i];
        if(slotData){
          const img = document.createElement('img');
          img.src = slotData.texture;
          img.style.width='100%';
          img.style.height='100%';
          btn.appendChild(img);

          if(slotData.count>1){
            if(slotData.count>1){
  const countDiv = document.createElement('div');
  countDiv.classList.add('count');
  countDiv.textContent = slotData.count;
  btn.appendChild(countDiv);
}

            const countDiv = document.createElement('div');
            countDiv.style.position='absolute';
            countDiv.style.bottom='2px';
            countDiv.style.right='2px';
            countDiv.style.color='white';
            countDiv.style.fontSize='12px';
            countDiv.textContent = slotData.count;
            btn.appendChild(countDiv);
          }
        }
      }
      
      btn.classList.toggle('selected', i===selectedSlot);
      btn.dataset.index = i;
      btn.onclick = ()=>{ selectedSlot=i; renderHotbar(); };
    });
  });
}

// inicializar
initInventorySelection();

function getBlock(wx, wy){
  let chunkX = Math.floor(wx/CHUNK_SIZE);
  let localX = wx - chunkX*CHUNK_SIZE;
  let chunk = generateChunk(chunkX);
  if(chunk.data[wy] && chunk.data[wy][localX] !== undefined) return chunk.data[wy][localX];
  return null;
}

function setBlock(wx, wy, type){
  let chunkX = Math.floor(wx/CHUNK_SIZE);
  let localX = wx - chunkX*CHUNK_SIZE;
  let chunk = generateChunk(chunkX);
  if(chunk.data[wy]) chunk.data[wy][localX] = type;
}

function drawChunks(){
  let startChunk = Math.floor((cameraX/BLOCK_SIZE)/CHUNK_SIZE) -1;
  let endChunk = Math.floor((cameraX + width)/BLOCK_SIZE/CHUNK_SIZE) +1;
  for(let cx=startChunk; cx<=endChunk; cx++){
    let chunk = generateChunk(cx);
    for(let y=0; y<ROWS; y++){
      for(let x=0; x<CHUNK_SIZE; x++){
        const type = chunk.data[y][x];
        if(type){
          const tex = textures[type];
          if(tex.complete){
            ctx.drawImage(tex, (cx*CHUNK_SIZE + x)*BLOCK_SIZE - cameraX, y*BLOCK_SIZE - cameraY, BLOCK_SIZE, BLOCK_SIZE);
          }
        }
      }
    }
  }
}



document.getElementById('left').addEventListener('touchstart', () => {
  leftPressed = true;
  lastDirection = {dx:-1, dy:0};
  player.facing = -1; // mirando izquierda
});

document.getElementById('right').addEventListener('touchstart', () => {
  rightPressed = true;
  lastDirection = {dx:1, dy:0};
  player.facing = 1; // mirando derecha
});

// === Texturas del jugador ===
const playerFrames = [];
for (let i = 1; i <= 4; i++) {
  const img = new Image();
  img.src = `Texturas/Cubs${i}.png`;
  playerFrames.push(img);
}
const crouchFrames = [];
for (let i = 1; i <= 4; i++) {
  const img = new Image();
  img.src = `Texturas/Cub_agachado${i}.png`;
  crouchFrames.push(img);
}

let crouching = false; // variable que indica si el jugador está agachado

let currentFrame = 0;
let frameTimer = 0;

// Cambiamos el jugador a usar texturas
let player = { 
  x:5, y:30, width:0.8, height:0.8, 
  vx:0, vy:0, onGround:false, 
  facing: 1 // 1 = derecha, -1 = izquierda
};

// === Dibujar jugador con animación ===
function drawPlayer(dt) {
  const frames = crouching ? crouchFrames : playerFrames;

  // actualizar frame solo si se mueve y no solo por estar agachado
  if ((leftPressed || rightPressed)) {
    frameTimer += dt;
    if (frameTimer >= 0.2) { // 5 fps
      frameTimer = 0;
      currentFrame = (currentFrame + 1) % frames.length;
    }
  } else {
    currentFrame = 0; // si no se mueve, siempre frame inicial
  }

  const img = frames[currentFrame];
  if (!img.complete) return;

  const px = player.x*BLOCK_SIZE - cameraX;
  const py = player.y*BLOCK_SIZE - cameraY;
  const pw = player.width*BLOCK_SIZE;
  const ph = player.height*BLOCK_SIZE;

  ctx.save();
  if (player.facing === 1) {
    ctx.translate(px + pw, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(img, 0, py, pw, ph);
  } else {
    ctx.drawImage(img, px, py, pw, ph);
  }
  ctx.restore();
}


const gravity = 0.8;
const jumpPower = -15;
const playerSpeed = 0.12;
let speed = crouching ? playerSpeed * 0.4 : playerSpeed;

let cameraX=0, cameraY=0;

function isBlock(wx, wy){ return getBlock(Math.floor(wx), Math.floor(wy)) !== null; }

let collidingLeft=false, collidingRight=false, collidingTop=false, collidingBottom=false;
function movePlayer() {
  collidingLeft=false; collidingRight=false; collidingTop=false; collidingBottom=false;

  // --- Lógica de soporte al agacharse ---
  if(crouching && player.vx !== 0) {
    let ny = player.y + player.height + 0.01;
    let underCenter = isBlock(player.x + player.width/2, ny);

    if(player.vx < 0) { // izquierda
      let underLeft = isBlock(player.x, ny);
      if(!underLeft && !underCenter) player.vx = 0;
    } else if(player.vx > 0) { // derecha
      let underRight = isBlock(player.x + player.width, ny);
      if(!underRight && !underCenter) player.vx = 0;
    }
  }

  // --- Movimiento horizontal normal ---
  let nx = player.x + player.vx;
  if(player.vx < 0){
    if(!isBlock(nx, player.y) && !isBlock(nx + player.width, player.y) &&
       !isBlock(nx, player.y + player.height - 0.01) && !isBlock(nx + player.width, player.y + player.height - 0.01)) {
      player.x = nx;
    } else { 
      player.vx = 0; 
      collidingLeft = true; 
    }
  } else if(player.vx > 0){
    if(!isBlock(nx, player.y) && !isBlock(nx + player.width, player.y) &&
       !isBlock(nx, player.y + player.height - 0.01) && !isBlock(nx + player.width, player.y + player.height - 0.01)) {
      player.x = nx;
    } else { 
      player.vx = 0; 
      collidingRight = true; 
    }
  }

  // --- Movimiento vertical ---
  player.vy += gravity;
  let ny = player.y + player.vy / BLOCK_SIZE;
  player.onGround = false;

  if(player.vy > 0){ // cayendo
    if(!isBlock(player.x, ny + player.height) && !isBlock(player.x + player.width, ny + player.height)) {
      player.y = ny;
    } else {
      player.y = Math.floor(ny + player.height) - player.height;
      player.vy = 0; 
      player.onGround = true; 
      collidingBottom = true;
    }
  } else if(player.vy < 0){ // subiendo
    if(!isBlock(player.x, ny) && !isBlock(player.x + player.width, ny)) {
      player.y = ny;
    } else {
      player.vy = 0; 
      collidingTop = true;
    }
  }
}

function initInventorySlots() {
  const allSlots = document.querySelectorAll('#inventory-grid .slot');
  allSlots.forEach((slot, i)=>{
    slot.dataset.index = i+9; // los 9 primeros slots son hotbar
    slot.onclick = ()=>{
      if(selectedSlot!==null) renderHotbar(); // quitar anterior selección
      selectedSlot = parseInt(slot.dataset.index);
      renderHotbar();
      console.log('Slot seleccionado:', selectedSlot);
    };
  });
}
initInventorySlots();
renderHotbar();

// Última dirección presionada (por defecto derecha)
// Última dirección presionada (por defecto derecha)
let lastDirection = {dx:1, dy:0};

// Variables de estado de los botones
let leftPressed = false, rightPressed = false, jumpPressed = false, downPressed = false;

// Controles táctiles y actualización de dirección
document.getElementById('left').addEventListener('touchstart', () => {
  leftPressed = true;
  lastDirection = {dx:-1, dy:0};
});
document.getElementById('left').addEventListener('touchend', () => leftPressed=false);

document.getElementById('right').addEventListener('touchstart', () => {
  rightPressed = true;
  lastDirection = {dx:1, dy:0};
});
document.getElementById('right').addEventListener('touchend', () => rightPressed=false);

document.getElementById('jump').addEventListener('touchstart', () => {
  jumpPressed = true;
  lastDirection = {dx:0, dy:-1}; // arriba
});
document.getElementById('jump').addEventListener('touchend', () => jumpPressed=false);

document.getElementById('down').addEventListener('touchstart', () => {
  if (breakMode) {
    lastDirection = {dx:0, dy:1}; // abajo
  } else {
    crouching = !crouching; // agacharse normal
  }
  downPressed = true;
});
document.getElementById('down').addEventListener('touchend', () => downPressed=false);

document.getElementById('down').addEventListener('touchend', () => {
  downPressed = false;
});

// Botón PRI
let breakMode = false;
const priBtn = document.getElementById('pri-btn');
priBtn.addEventListener('touchstart', () => {
  breakMode = !breakMode;
  if(breakMode) priBtn.classList.add('active');
  else { priBtn.classList.remove('active'); stopBreaking(); }
});

// Datos de bloques
const blockData = {
  'stone': {time:30},
  'dirt': {time:5},
  'grass': {time:5}
};

// Romper bloques
let breaking = {active:false, wx:0, wy:0, progress:0, time:0, type:null, delay:0};

function handleBreaking(dt){
  if(!breakMode || !lastDirection) { stopBreaking(); return; }

  // Calculamos bloque objetivo según última dirección
  let wx, wy;

if(lastDirection.dy > 0){
  // romper abajo
  wx = Math.floor(player.x + player.width/2);
  wy = Math.floor(player.y + player.height);
} else if(lastDirection.dy < 0){
  // romper arriba
  wx = Math.floor(player.x + player.width/2);
  wy = Math.floor(player.y - 1);
} else {
  // romper izquierda/derecha
  wx = Math.floor(player.x + lastDirection.dx);
  wy = Math.floor(player.y + player.height/2);
}


  let type = getBlock(wx, wy);
if(!type) { stopBreaking(); return; }

// Si bloque nuevo o diferente, reinicia progreso
if(!breaking.active || breaking.wx!==wx || breaking.wy!==wy){
  breaking.active = true;
  breaking.wx = wx;
  breaking.wy = wy;
  breaking.type = type;
  breaking.time = 0;
  breaking.progress = 0;
  breaking.delay = 0;
}


  // Retardo antes de romper
  breaking.delay += dt;
  if(breaking.delay >= 0.5){
    updateBreaking(dt);
  }
}

function updateBreaking(dt){
  if(!breaking.active) return;

  let maxTime = 5; // por defecto
  if(blockData[breaking.type]) maxTime = blockData[breaking.type].time;

  breaking.time += dt;
  breaking.progress = Math.min(breaking.time/maxTime,1);

  if(breaking.progress >= 1){
    setBlock(breaking.wx, breaking.wy, null);
    
  }
}

function stopBreaking(){
  breaking.active=false;
  breaking.wx=0; breaking.wy=0; breaking.type=null; breaking.time=0; breaking.progress=0; breaking.delay=0;
}
function updateBreaking(dt){
  if(!breaking.active) return;
  let maxTime = 5; 
  if(blockData[breaking.type]) maxTime = blockData[breaking.type].time;
  breaking.time += dt;
  breaking.progress = Math.min(breaking.time/maxTime,1);

  if(breaking.progress>=1){
    setBlock(breaking.wx, breaking.wy,null);
    addItem(breaking.type); // se añade al inventario
    stopBreaking();
  }
}

function drawBreaking(){
  if(breaking.active && breaking.type){
    let stage = Math.floor(breaking.progress*4);
    let img = crackTextures[stage];
    if(img.complete) ctx.drawImage(img, breaking.wx*BLOCK_SIZE-cameraX, breaking.wy*BLOCK_SIZE-cameraY, BLOCK_SIZE, BLOCK_SIZE);
  }
}
function addItem(type){
  const textureMap = {stone:'Texturas/piedra.jpg', dirt:'Texturas/tierra.jpg', grass:'Texturas/cesped_parte_costado.jpg'};
  let tex = textureMap[type];
  // Buscar stack existente
  let slot = inventory.find(s => s && s.type===type);
  if(slot){ slot.count++; renderHotbar(); return; }
  // Buscar primer slot vacío
  let emptyIndex = inventory.findIndex(s=>!s);
  if(emptyIndex>=0){ inventory[emptyIndex]={type, texture:tex, count:1}; renderHotbar(); }
  else console.log('Inventario lleno');
}
function placeBlock(wx, wy){
  const slot = inventory[selectedSlot];
  if(!slot) return;
  if(getBlock(wx, wy)===null){
    setBlock(wx, wy, slot.type);
    slot.count--;
    if(slot.count<=0) inventory[selectedSlot]=null;
    renderHotbar();
  }
}

// Touch para colocar bloque
canvas.addEventListener('touchstart', e=>{
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const cx = touch.clientX - rect.left;
  const cy = touch.clientY - rect.top;

  const wx = Math.floor((cx + cameraX)/BLOCK_SIZE);
  const wy = Math.floor((cy + cameraY)/BLOCK_SIZE);
  placeBlock(wx, wy);
});
function placeBlock(wx, wy){
  const slot = inventory[selectedSlot];
  if(!slot) return;
  if(getBlock(wx, wy)===null){
    setBlock(wx, wy, slot.type);
    slot.count--;
    if(slot.count<=0) inventory[selectedSlot]=null;
    renderHotbar();
  }
}

// Touch para colocar bloque
canvas.addEventListener('touchstart', e=>{
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const cx = touch.clientX - rect.left;
  const cy = touch.clientY - rect.top;

  const wx = Math.floor((cx + cameraX)/BLOCK_SIZE);
  const wy = Math.floor((cy + cameraY)/BLOCK_SIZE);
  placeBlock(wx, wy);
});

// Juego principal
let lastTime = performance.now();
function gameLoop(time){
  let dt = (time - lastTime)/1000;
  lastTime = time;

  ctx.clearRect(0,0,width,height);

// velocidad dinámica: normal o agachado
let speed = crouching ? playerSpeed * 0.4 : playerSpeed;

player.vx = 0;
if (leftPressed) player.vx = -speed;
if (rightPressed) player.vx = speed;

if (jumpPressed && player.onGround) player.vy = jumpPower;

  movePlayer();
  cameraX = player.x*BLOCK_SIZE - width/2 + BLOCK_SIZE/2;
  cameraY = player.y*BLOCK_SIZE - height/2 + BLOCK_SIZE/2;

  handleBreaking(dt);
  updateBreaking(dt);

  drawChunks();
  drawBreaking();

  drawPlayer(dt);

  requestAnimationFrame(gameLoop);
}
gameLoop();
</script>
</body>
</html>
