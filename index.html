<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CUBOX</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  font-family: 'Press Start 2P', monospace;
}

canvas {
  display: block;
  background: #87CEEB;
  font-family: 'Press Start 2P', monospace;
}


/* Contenedor de controles */
/* Contenedor normal de controles */
#controls {
  position: fixed;
  bottom: 10px;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-between;
  padding: 0 20px;
  pointer-events: none; /* ← importante, evita que tape clicks */
}

.left-controls,
.right-controls {
  display: flex;
  gap: 10px;
  pointer-events: auto; /* ← los hijos sí reciben toques */
}

/* Fondo borroso */
#blur-bg {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  backdrop-filter: blur(5px);
  background: rgba(0,0,0,0.2);
  display: none;
  z-index: 900;
}

/* Botón de pausa pequeño */
#pause-btn {
  position: fixed;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  width: 40px;
  height: 30px;
  background-color: rgba(100,100,100,0.6);
  color: white;
  border: 2px solid white;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  z-index: 1000;
  touch-action: manipulation;
  display: flex;
  flex-direction: column;
  justify-content: space-around; /* distribuye las barras */
  align-items: center;
  box-sizing: border-box;
}



/* Menú de pausa */
#pause-menu {
  position: fixed;
  top: 100px;
  left: 50%;
  transform: translateX(-50%);
  width: 200px;
  background: #555;
  border: 2px solid #000;
  display: none;
  flex-direction: column;
  align-items: center;
  font-family: 'Press Start 2P', monospace;
  z-index: 1001;
}

.menu-btn {
  background: #888;
  color: #000;
  border: 2px solid #000;
  padding: 6px;
  margin: 4px 0;
  width: 100%;
  text-align: center;
  cursor: pointer;
  user-select: none;
}

/* Panel de ajustes deslizable desde la derecha */
#settings-panel {
  position: fixed;
  top: 50px;
  right: -240px; /* fuera de la pantalla al inicio */
  width: 220px;
  height: 250px;
  background: #555;
  border: 2px solid #000;
  display: flex;
  flex-direction: column;
  z-index: 1002;
  transition: right 0.3s ease;
}

#settings-panel.active {
  right: 10px; /* cuando está abierto */
}

#settings-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: #777;
  border-bottom: 2px solid #000;
  padding: 4px 8px;
  font-family: 'Press Start 2P', monospace;
}

#close-settings {
  cursor: pointer;
}

#settings-content {
  flex: 1;
  overflow-y: auto;
  padding: 6px;
}
#volume-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  background: #777;
  border: 2px solid #000;
  border-radius: 4px;
  padding: 4px 8px;
  margin: 6px 0;
  font-family: 'Press Start 2P', monospace;
}

#volume-controls button {
  background: #555;
  color: #fff;
  border: 2px solid #000;
  border-radius: 4px;
  padding: 4px 8px;
  margin: 0 4px;
  cursor: pointer;
  font-family: 'Press Start 2P', monospace;
}

#volume-controls button:hover {
  background: #666;
}

#vol-label {
  min-width: 30px;
  text-align: center;
}

p {
  font-family: 'Press Start 2P', monospace;
  margin: 6px 0;
  text-align: center;
}

#music-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 10px 0;
  gap: 8px;
}

#prevTrack,
#nextTrack {
  background-color: #555;
  color: #fff;
  border: 2px solid #000;
  border-radius: 6px;
  padding: 6px 12px;
  cursor: pointer;
  font-family: 'Press Start 2P', monospace;
  transition: background 0.2s;
  font-size: 10px;
}

#prevTrack:hover,
#nextTrack:hover {
  background-color: #666;
}

#currentTrack {
  font-family: 'Press Start 2P', monospace;
  min-width: 120px;
  max-width: 180px;
  text-align: center;
  display: inline-block;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 8px; /* texto más pequeño */
}

.setting-btn {
  background: #888;
  color: #000;
  border: 2px solid #000;
  padding: 6px;
  margin: 4px 0;
  width: 100%;
  text-align: center;
  cursor: pointer;
  user-select: none;
}

/* Botón PRI separado y más arriba */
#pri-container {
  position: fixed;
  right: 10px;
  bottom: 100px; /* más arriba que los otros botones */
  z-index: 10;
}

/* Estilo común para todos los botones */
.control-btn {
  width: 64px;
  height: 40px;
  background-color: rgba(100, 100, 100, 0.5);
  border: 2px solid white;
  color: white;
  text-align: center;
  line-height: 40px;
  font-weight: bold;
  border-radius: 8px;
  user-select: none;
  touch-action: none;
}

/* PRI activo */
#pri-btn.active {
  background-color: rgba(200, 50, 50, 0.7);
}



.control-btn.active {
  outline: 3px solid yellow; /* borde sin afectar tamaño */
  border: 2px solid white;   /* borde original se mantiene */
  box-shadow: none;
  transform: none;
}




#inventory-btn {
  position: fixed;
  left: 10px;
  bottom: 100px;
  width: 60px;
  height: 40px;
  background-color: rgba(100, 100, 100, 0.6);
  color: white;
  border: 2px solid white;
  border-radius: 6px;
  font-weight: bold;
  font-family: 'Press Start 2P', monospace;
  cursor: pointer;
  z-index: 40;
  touch-action: manipulation;
  display: flex;
  justify-content: center;
  align-items: center;
}

#inventory-btn:active {
  background-color: rgba(120, 120, 120, 0.8);
}


#fps-counter {
  position: fixed;
  top: 5px;
  left: 5px;
  color: white;
  background: rgba(0, 0, 0, 0.5);
  padding: 4px 6px;
  border-radius: 4px;
  font-family: 'Press Start 2P', monospace;
  display: none;
  font-size: 10px;
  z-index: 50;
}


#object-controls {
  position: fixed;
  bottom: 10px;
  left: 300px;
  width: 220px;
  background: #111;
  border: 2px solid #0f0;
  color: #0f0;
  font-family: monospace;
  padding: 10px;
  z-index: 100;
  user-select: none;
  box-shadow: 4px 4px 0 #000;
  cursor: grab;
}

#object-controls.dragging {
  cursor: grabbing;
}

#settings-header {
  font-weight: bold;
  text-align: center;
  margin-bottom: 5px;
}

#panel-msg {
  text-align: center;
  font-size: 12px;
  color: #ff0;
  opacity: 0;
  transition: opacity 0.3s;
  margin-bottom: 5px;
}

.control-row {
  display: flex;
  justify-content: space-between;
  margin: 3px 0;
}

button {
  background: #222;
  color: #0f0;
  border: 2px solid #0f0;
  font-family: monospace;
  cursor: pointer;
  padding: 2px 5px;
  user-select: none;
}

button:active {
  background: #0f0;
  color: #222;
}
#orientation-panel {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  backdrop-filter: blur(8px);
  background-color: rgba(0,0,0,0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

#orientation-panel img {
  max-width: 80%;
  max-height: 80%;
}

.hidden {
  display: none;
}
/* ===== INVENTARIO GENERAL ===== */
#inventory-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(20,20,20,0.95);
  padding: 12px;
  border: 3px solid #555;
  border-radius: 8px;
  display: none; /* Se muestra al abrir inventario */
  z-index: 30;
  font-family: monospace;
  color: white;
  transform-origin: center;
  zoom: 0.8; /* Ajusta tamaño general */
}

/* Grid del inventario (9x3) */
#inventory-grid {
  display: grid;
  grid-template-columns: repeat(9, 36px);
  gap: 4px;
  margin-bottom: 10px;
  justify-content: center;
}

/* Hotbar dentro del inventario */
#hotbar {
  display: flex;
  gap: 4px;
  justify-content: center;
  margin-top: 8px;
}

/* ===== SLOTS ===== */
.slot {
  width: 36px;
  height: 36px;
  background: #333;
  border: 2px solid #777;
  border-radius: 3px;
  cursor: pointer;
  position: relative;
  overflow: hidden;
}

.slot img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  pointer-events: none;
}

.slot.selected {
  border: 2px solid yellow;
}


/* ===== CRAFTING ===== */
#crafting-section {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  margin-top: 10px;
}

/* Grid de 2x2 */
#crafting-grid {
  display: grid;
  grid-template-columns: repeat(2, 36px);
  grid-template-rows: repeat(2, 36px);
  gap: 4px;
}

.craft-slot {
  background: #444;
  border: 2px solid #777;
}

/* Flecha de crafteo */
.arrow {
  font-size: 18px;
  font-weight: bold;
  color: white;
}

/* Resultado de crafteo */
#craft-result {
  background: #555;
  border: 2px solid #aaa;
}

/* ===== HOTBAR FIJA EN PANTALLA ===== */
#hotbar-fixed {
  position: fixed;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 4px;
  background: rgba(0,0,0,0.5);
  padding: 4px;
  border-radius: 6px;
  z-index: 20;
}

#hotbar-fixed .slot {
  width: 34px;
  height: 34px;
}
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

#overlay413 {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  backdrop-filter: blur(8px);
  background: rgba(0,0,0,0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

#starmp3 {
  font-size: 16px;
  padding: 20px 40px;
  background: #2ecc71;
  color: black;
  border: 4px solid #000;
  cursor: pointer;
  image-rendering: pixelated;
  box-shadow: 4px 4px 0 #000;
  transition: transform 0.1s;
  animation: blink413 1s step-start infinite;
  font-family: 'Press Start 2P', monospace;
}

#starmp3:active {
  transform: translate(2px, 2px);
  box-shadow: 2px 2px 0 #000;
}

@keyframes blink413 {
  50% { opacity: 0.4; }
}


</style>
</head>
<body>
  <div id="overlay413">
  <button id="starmp3">▶ COMENZAR</button>
</div>

<audio id="player413"></audio>

  <div id="orientation-panel">
  <img src="Texturas/horizontal.png" alt="Gira pantalla">
</div>

  <!-- Panel inicial -->
<div id="init-panel" style="
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.8);
  color: white;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 100;
  font-family: sans-serif;
">
  
  <p style="font-size: 18px; margin-bottom: 20px;">¿Quieres borrar el localStorage de los controles?</p>
  <div>
    <button id="init-yes" style="margin-right: 10px; padding: 10px 20px;">Sí</button>
    <button id="init-no" style="padding: 10px 20px;">No</button>
  </div>
</div>
<div id="pause-btn">▐▐</div>
<div id="blur-bg"></div>



<div id="pause-menu">
  <div class="menu-btn" id="resume-btn">Reanudar</div>
  <div class="menu-btn" id="exit-btn">Salir</div>
  <div class="menu-btn" id="settings-btn">Ajustes</div>
</div>

<div id="settings-panel">
    <div id="settings-header">
      Ajustes
      <div id="close-settings">×</div>
    </div>
    <div id="settings-content">
    

<h3>volumen de musica</h3>
<div id="volume-controls">
  <button id="vol-down">-</button>
  <span id="vol-label">50</span>
  <button id="vol-up">+</button>
</div>
<p>musica:</p>
<div id="music-controls">
  <button id="prevTrack">⏮️</button>
  <span id="currentTrack">[Nombre de la música]</span>
  <button id="nextTrack">⏭️</button>
</div>

      <div id="fps-toggle" class="setting-btn">mostrar fps: no</div>
      <div id="controls-btn" class="setting-btn">CONTROLS</div>
    </div>
  </div>

  <div id="fps-counter"></div>
<div id="object-controls" style="display:none;">
  <div id="settings-header">Ajustes de objeto</div>
  <div id="panel-msg"></div>
  <div>Objeto seleccionado: <span id="selected-name">Ninguno</span></div>

  <div class="control-row">
    <label>Pos X:</label>
    <button id="posx-minus">-</button>
    <button id="posx-plus">+</button>
  </div>
  <div class="control-row">
    <label>Pos Y:</label>
    <button id="posy-minus">-</button>
    <button id="posy-plus">+</button>
  </div>
  <div class="control-row">
    <label>Escala X:</label>
    <button id="scalex-minus">-</button>
    <button id="scalex-plus">+</button>
  </div>
  <div class="control-row">
    <label>Escala Y:</label>
    <button id="scaley-minus">-</button>
    <button id="scaley-plus">+</button>
  </div>

  <div class="control-row">
    <button id="save-btn">Guardar</button>
    <button id="reset-btn">Restablecer</button>
    <button id="confirm-btn">Cerrar</button>
  </div>
</div>

<canvas id="gameCanvas"></canvas>
<!-- Hotbar fija en pantalla -->
<!-- Botón para abrir inventario -->
<button id="inventory-btn">INV</button>

<!-- INVENTARIO Y CRAFTING -->
<div id="inventory-panel">
  <!-- Grid del inventario 9x3 -->
  <div id="inventory-grid">
    <!-- 27 slots de ejemplo -->
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>

    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
  </div>

  <!-- Crafting 2x2 -->
  <div id="crafting-section">
    <div id="crafting-grid">
      <button class="slot craft-slot"></button>
      <button class="slot craft-slot"></button>
      <button class="slot craft-slot"></button>
      <button class="slot craft-slot"></button>
    </div>
    <div class="arrow">➡</div>
    <button class="slot" id="craft-result"></button>
  </div>

  <!-- Hotbar dentro del inventario -->
  <div id="hotbar">
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
    <button class="slot"></button>
  </div>
</div>

<!-- Hotbar fija abajo -->
<div id="hotbar-fixed">
  <button class="slot"></button>
  <button class="slot"></button>
  <button class="slot"></button>
  <button class="slot"></button>
  <button class="slot"></button>
  <button class="slot"></button>
  <button class="slot"></button>
  <button class="slot"></button>
  <button class="slot"></button>
</div>


<div id="controls">
  <div class="left-controls">
    <div class="control-btn" id="left">◀</div>
    <div class="control-btn" id="right">▶</div>
  </div>
  <div class="right-controls">
    <div class="control-btn" id="down">▼</div>
    <div class="control-btn" id="jump">▲</div>
  </div>
</div>

<div id="pri-container">
  <div class="control-btn" id="pri-btn">PRI</div>
  <div class="control-btn" id="pri-bg-btn">BG</div>
</div>

</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width = window.innerWidth;
let height = window.innerHeight;

const scale = window.devicePixelRatio || 1; // detecta si es 2K, 4K, etc.
canvas.width = width * scale;
canvas.height = height * scale;
canvas.style.width = width + "px";
canvas.style.height = height + "px";
ctx.scale(scale, scale);


let BLOCK_SIZE = 100; // valor inicial

function setZoom(level) {
  BLOCK_SIZE = level; // ejemplo: setZoom(80) → más cerca
}
let selectedObject = null;
const factoryStyles = new WeakMap();
const panel2 = document.getElementById('orientation-panel');

// Solo mostrar el panel si se carga en vertical
if(window.innerWidth > window.innerHeight){
  panel2.style.display = 'none';
}

let lastOrientation = window.innerWidth > window.innerHeight;

setInterval(() => {
  const isHorizontal = window.innerWidth > window.innerHeight;

  if(isHorizontal !== lastOrientation){
    lastOrientation = isHorizontal;

    // Si gira a horizontal desde vertical, recarga
    if(isHorizontal){
      location.reload();
    }
  }
}, 300);

const panel = document.getElementById("object-controls");
const msgBox = document.getElementById("panel-msg");

document.getElementById("controls-btn").addEventListener("click", () => {
  panel.style.display = panel.style.display === "none" ? "block" : "none";
});

function showMessage(text, duration = 1500) {
  if (!msgBox) return;
  msgBox.textContent = text;
  msgBox.style.opacity = "1";
  setTimeout(() => msgBox.style.opacity = "0", duration);
}

function initSelected(obj) {
  if (!panel || panel.style.display === "none") return;
  if (!obj.id) { 
    showMessage("Objeto necesita ID único");
    return; 
  }

  selectedObject = obj;
  selectedObject.style.position = "absolute"; // fuerza movible
  document.getElementById("selected-name").textContent = obj.id;

  if (!factoryStyles.has(obj)) {
    const style = window.getComputedStyle(obj);
    factoryStyles.set(obj, {
      left: style.left || obj.offsetLeft + "px",
      top: style.top || obj.offsetTop + "px",
      width: style.width || obj.offsetWidth + "px",
      height: style.height || obj.offsetHeight + "px"
    });
  }

  const key = "object-" + obj.id;
  const saved = localStorage.getItem(key);
  if (saved) {
    const data = JSON.parse(saved);
    obj.style.left = data.left;
    obj.style.top = data.top;
    obj.style.width = data.width;
    obj.style.height = data.height;
  }
}

document.addEventListener("click", e => {
  if (!panel || panel.style.display === "none") return;
  if (e.target.closest("#object-controls") || e.target.closest("#controls-btn")) return;
  
  const obj = e.target.closest("[id]");
  if (!obj) return;

  initSelected(obj);
});

function changeStylePx(prop, delta) {
  if (!selectedObject) return;
  let current = parseFloat(selectedObject.style[prop]) || 
      (prop.includes("width") ? selectedObject.offsetWidth : selectedObject.offsetHeight);
  selectedObject.style[prop] = (current + delta) + "px";
}

function holdButtonPx(button, prop, delta) {
  let frame;
  const step = () => {
    changeStylePx(prop, delta);
    frame = requestAnimationFrame(step);
  };
  button.addEventListener("mousedown", e => { e.preventDefault(); step(); });
  button.addEventListener("touchstart", e => { e.preventDefault(); step(); });
  ["mouseup","mouseleave","touchend","touchcancel"].forEach(ev => {
    button.addEventListener(ev, () => cancelAnimationFrame(frame));
  });
}

holdButtonPx(document.getElementById("posx-plus"), "left", 2);
holdButtonPx(document.getElementById("posx-minus"), "left", -2);
holdButtonPx(document.getElementById("posy-plus"), "top", 2);
holdButtonPx(document.getElementById("posy-minus"), "top", -2);
holdButtonPx(document.getElementById("scalex-plus"), "width", 2);
holdButtonPx(document.getElementById("scalex-minus"), "width", -2);
holdButtonPx(document.getElementById("scaley-plus"), "height", 2);
holdButtonPx(document.getElementById("scaley-minus"), "height", -2);

document.getElementById("save-btn").addEventListener("click", () => {
  if (!selectedObject) return;
  const key = "object-" + selectedObject.id;
  const data = {
    left: selectedObject.style.left,
    top: selectedObject.style.top,
    width: selectedObject.style.width,
    height: selectedObject.style.height
  };
  localStorage.setItem(key, JSON.stringify(data));
  showMessage("Guardado");
});

document.getElementById("reset-btn").addEventListener("click", () => {
  if (!selectedObject) return;
  const original = factoryStyles.get(selectedObject);
  if (!original) return;
  selectedObject.style.left = original.left;
  selectedObject.style.top = original.top;
  selectedObject.style.width = original.width;
  selectedObject.style.height = original.height;
  showMessage("Restablecido");
});

document.getElementById("confirm-btn").addEventListener("click", () => {
  panel.style.display = "none";
});

window.addEventListener("load", () => {
  document.querySelectorAll("[id]").forEach(el => {
    const key = "object-" + el.id;
    const saved = localStorage.getItem(key);
    if (saved) {
      const data = JSON.parse(saved);
      el.style.position = "absolute";
      el.style.left = data.left;
      el.style.top = data.top;
      el.style.width = data.width;
      el.style.height = data.height;
    }
  });
});
const initPanel = document.getElementById("init-panel");
const yesBtn = document.getElementById("init-yes");
const noBtn = document.getElementById("init-no");

yesBtn.addEventListener("click", () => {
  localStorage.clear(); // borra todo

  // Mostramos mensaje indicando que cierre la app
  initPanel.innerHTML = `
    <p style="font-size: 18px; margin-bottom: 20px;">
      LocalStorage borrado. Por favor, cierra el juego y vuelve a abrir para iniciar limpio,al volver a ver las opciones de "si" y "no" presiona [no] para no repetir este proceso.
    </p>
  `;
});

noBtn.addEventListener("click", () => {
  initPanel.style.display = "none"; // solo ocultar panel
});
window.addEventListener("load", () => {
  const starmp3 = document.getElementById("starmp3");
  const player413 = document.getElementById("player413");
  const overlay413 = document.getElementById("overlay413");
  const currentTrackElem = document.getElementById("currentTrack");
  const prevTrackBtn = document.getElementById("prevTrack");
  const nextTrackBtn = document.getElementById("nextTrack");

  const tracks413 = [
    "Texturas/8dark.wav",
    "Texturas/8Epic.wav",
    "Texturas/Alones413.wav",
    "Texturas/8Rlx.wav"
  ];

  let playlist413 = [];
  let playedTracks = [];
  let currentTrack = "";

  function shufflePlaylist() {
    playlist413 = [...tracks413];
    playedTracks = [];
    pickNextTrack();
  }

  function pickNextTrack() {
    if (playlist413.length === 0) {
      playlist413 = [...playedTracks];
      playedTracks = [];
    }
    const randomIndex = Math.floor(Math.random() * playlist413.length);
    currentTrack = playlist413.splice(randomIndex, 1)[0];
    playedTracks.push(currentTrack);
    updateCurrentTrackDisplay();
    player413.src = currentTrack;
    player413.play().catch(err => console.error(err));
  }

  function pickPrevTrack() {
    if (playedTracks.length > 1) {
      playlist413.unshift(playedTracks.pop());
      currentTrack = playedTracks[playedTracks.length - 1];
      updateCurrentTrackDisplay();
      player413.src = currentTrack;
      player413.play().catch(err => console.error(err));
    }
  }

  function updateCurrentTrackDisplay() {
    const name = currentTrack.split("/").pop();
    currentTrackElem.textContent = `<${name}>`;
  }

  function openFullscreen() {
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen();
    } else if (document.documentElement.webkitRequestFullscreen) {
      document.documentElement.webkitRequestFullscreen();
    } else if (document.documentElement.msRequestFullscreen) {
      document.documentElement.msRequestFullscreen();
    }
  }

  starmp3.addEventListener("click", async () => {
    try {
      openFullscreen();
      shufflePlaylist();
      overlay413.style.display = "none";
      player413.muted = false;
      player413.volume = (window.orientation === 90 || window.orientation === -90) ? 1 : 0;
      await player413.play();
    } catch(e) {
      console.error("Error al reproducir audio:", e);
    }
  });

  window.addEventListener("orientationchange", () => {
    if (player413.src) {
      player413.volume = (window.orientation === 90 || window.orientation === -90) ? 1 : 0;
    }
  });

  prevTrackBtn.addEventListener("click", pickPrevTrack);
  nextTrackBtn.addEventListener("click", pickNextTrack);
});

// --- controles de volumen ---
const volDown = document.getElementById("vol-down");
const volUp   = document.getElementById("vol-up");
const volLabel = document.getElementById("vol-label");

// volumen inicial (cargar desde localStorage o usar 0.5 por defecto)
let volume = parseFloat(localStorage.getItem("musicVolume")) || 0.5;
player413.volume = volume;
volLabel.textContent = Math.round(volume * 100);

// actualizar volumen en pantalla y guardar
function updateVolume() {
  player413.volume = volume;
  volLabel.textContent = Math.round(volume * 100);
  localStorage.setItem("musicVolume", volume.toFixed(2));
}

// bajar volumen
volDown.addEventListener("click", () => {
  volume = Math.max(0, volume - 0.1);
  updateVolume();
});

// subir volumen
volUp.addEventListener("click", () => {
  volume = Math.min(1, volume + 0.1);
  updateVolume();
});

let fpsVisible = false;
let fpsCounter = document.getElementById("fps-counter");
let fpsToggle = document.getElementById("fps-toggle");

let fpsValues = []; // guardamos varios FPS para hacer promedio
let lastFrame = performance.now();

// Alternar botón
fpsToggle.addEventListener("click", () => {
  fpsVisible = !fpsVisible;
  fpsToggle.textContent = "mostrar fps: " + (fpsVisible ? "sí" : "no");
  fpsCounter.style.display = fpsVisible ? "block" : "none";
});

// Loop para calcular fps por frame
function frameLoop() {
  let now = performance.now();
  let delta = (now - lastFrame) / 1000; // en segundos
  lastFrame = now;

  let fps = 1 / delta;
  fpsValues.push(fps);

  requestAnimationFrame(frameLoop);
}
frameLoop();

// Mostrar promedio cada 3 segundos
setInterval(() => {
  if (fpsVisible && fpsValues.length > 0) {
    let sum = fpsValues.reduce((a, b) => a + b, 0);
    let avg = Math.round(sum / fpsValues.length);
    fpsCounter.textContent = "FPS: " + avg;
    fpsValues = []; // vaciar para el siguiente ciclo
  }
}, 1000);

const ROWS = 100;
const CHUNK_SIZE = 20;

// Texturas
const textures = {};
textures.grass = new Image(); textures.grass.src = 'Texturas/cesped_parte_costado.jpg';
textures.dirt = new Image(); textures.dirt.src = 'Texturas/tierra.jpg';
textures.stone = new Image(); textures.stone.src = 'Texturas/piedra.jpg';
textures.leaf = new Image();  textures.leaf.src = 'Texturas/oja.png';
textures.log  = new Image();  textures.log.src  = 'Texturas/tronco.png';

const crackTextures = [];
for(let i=1;i<=5;i++){
  const img = new Image();
  img.src = `Texturas/crack${i}.png`;
  crackTextures.push(img);
}

// Generación de chunks
let chunks = {};
function generateChunk(chunkX){
  if(chunks[chunkX]) return chunks[chunkX];
  let surfaceHeight = ROWS-50;
  let currentHeight = surfaceHeight;
  let data = [];
  for(let x=0; x<CHUNK_SIZE; x++){
    let worldX = chunkX*CHUNK_SIZE + x;
    let change = Math.floor(Math.random()*3)-1;
    currentHeight += change;
    if(currentHeight<surfaceHeight-5) currentHeight = surfaceHeight-5;
    if(currentHeight>surfaceHeight+2) currentHeight = surfaceHeight+2;
    for(let y=0; y<ROWS; y++){
      if(!data[y]) data[y] = [];
      if(y<currentHeight) data[y][x] = null;
      else if(y===currentHeight) data[y][x]='grass';
      else if(y<currentHeight+3) data[y][x]='dirt';
      else data[y][x]='stone';
    }
  }
  chunks[chunkX] = {x: chunkX, data};
  return chunks[chunkX];
}
// === Capa de fondo (segunda capa) ===
let chunksBg = {};

function generateChunkBg(chunkX){
  if(chunksBg[chunkX]) return chunksBg[chunkX];

  let chunk = generateChunk(chunkX); 
  let data = [];

  for(let y=0; y<ROWS; y++){
    data[y] = [];
    for(let x=0; x<CHUNK_SIZE; x++){
      data[y][x] = chunk.data[y][x];
    }
  }

  // 🌳 Generación de árboles
  for(let x=0; x<CHUNK_SIZE; x++){
    for(let y=0; y<ROWS; y++){
      if(data[y][x] === 'grass'){ 
        // 10% de probabilidad de árbol en ese bloque
        if(Math.random() < 0.1){
          generateTree({data}, x, y);
        }
      }
    }
  }

  chunksBg[chunkX] = {x: chunkX, data};
  return chunksBg[chunkX];
}


const invBtn = document.getElementById('inventory-btn');
const invPanel = document.getElementById('inventory-panel');

invBtn.addEventListener('click', () => {
  if (invPanel.style.display === 'none' || invPanel.style.display === '') {
    invPanel.style.display = 'block'; // abrir
  } else {
    invPanel.style.display = 'none';  // cerrar
  }
});

const pauseBtn = document.getElementById('pause-btn');
const pauseMenu = document.getElementById('pause-menu');
const settingsPanel = document.getElementById('settings-panel');
const resumeBtn = document.getElementById('resume-btn');
const exitBtn = document.getElementById('exit-btn');
const settingsBtn = document.getElementById('settings-btn');
const closeSettings = document.getElementById('close-settings');
const blurBg = document.getElementById('blur-bg');

pauseBtn.addEventListener('click', () => {
  pauseMenu.style.display = 'flex';
  blurBg.style.display = 'block';
});

resumeBtn.addEventListener('click', () => {
  pauseMenu.style.display = 'none';
  settingsPanel.classList.remove('active');
  blurBg.style.display = 'none';
});

exitBtn.addEventListener('click', () => {
  // Función para salir del juego
});

settingsBtn.addEventListener('click', () => {
  settingsPanel.classList.add('active');
});

closeSettings.addEventListener('click', () => {
  settingsPanel.classList.remove('active');
});

let inventory = new Array(27).fill(null); 
let selectedSlot = 0; // slot seleccionado en hotbar
function generateTree(chunkBg, localX, groundY){
  // altura del tronco entre 3 y 5
  let height = 3 + Math.floor(Math.random()*3);

  // tronco
  for(let h=0; h<height; h++){
    if(chunkBg.data[groundY-h-1]) // aseguramos que exista fila
      chunkBg.data[groundY-h-1][localX] = 'log';
  }

  // hojas (alrededor de la punta)
  let top = groundY - height;
  for(let dx=-2; dx<=2; dx++){
    for(let dy=-2; dy<=2; dy++){
      let dist = Math.abs(dx) + Math.abs(dy);
      if(dist <= 2){ // forma de cruz / redondeada
        let yy = top+dy;
        let xx = localX+dx;
        if(chunkBg.data[yy] && chunkBg.data[yy][xx]!==undefined && chunkBg.data[yy][xx]===null){
          chunkBg.data[yy][xx] = 'leaf';
        }
      }
    }
  }
}

function initInventorySelection() {
  const allSlots = document.querySelectorAll('#inventory-grid .slot');
  allSlots.forEach((slot, i) => {
    slot.dataset.type = 'inv';
    slot.dataset.index = i + 9; // Inventario grande ocupa 9–35
  });
}


let pickedSlot = null;

function enableTouchInventory() {
  const allSlots = document.querySelectorAll(
    '#inventory-grid .slot, #hotbar .slot, #hotbar-fixed .slot, #crafting-grid .slot'
  );

  allSlots.forEach((slot, i) => {
    // Detectar si es crafteo o inventario
    if (slot.closest('#crafting-grid')) {
      slot.dataset.type = 'craft';
      slot.dataset.index = i % 4; // 0–3
    } else {
      slot.dataset.type = 'inv';
      // dataset.index ya lo asignan renderHotbar/initInventorySlots
    }

    slot.onclick = () => {
      if (!pickedSlot) {
        // Primer toque → seleccionar
        pickedSlot = slot;
        slot.classList.add('selected');
      } else if (pickedSlot === slot) {
        // Segundo toque en el mismo → cancelar
        slot.classList.remove('selected');
        pickedSlot = null;
      } else {
        // Segundo toque en otro slot → mover/intercambiar
        const fromType = pickedSlot.dataset.type;
        const toType   = slot.dataset.type;
        const fromIdx  = parseInt(pickedSlot.dataset.index);
        const toIdx    = parseInt(slot.dataset.index);

        if (fromType === 'inv' && toType === 'inv') {
          // Inventario ↔ Inventario
          let temp = inventory[toIdx];
          inventory[toIdx] = inventory[fromIdx];
          inventory[fromIdx] = temp;
          renderHotbar();
        }

        if (fromType === 'craft' && toType === 'craft') {
          // Craft ↔ Craft
          let temp = craftingGrid[toIdx];
          craftingGrid[toIdx] = craftingGrid[fromIdx];
          craftingGrid[fromIdx] = temp;
          renderCrafting();
        }

        if (fromType === 'inv' && toType === 'craft') {
          // Inventario → Craft
          craftingGrid[toIdx] = inventory[fromIdx];
          inventory[fromIdx] = null;
          renderHotbar();
          renderCrafting();
        }

        if (fromType === 'craft' && toType === 'inv') {
          // Craft → Inventario
          inventory[toIdx] = craftingGrid[fromIdx];
          craftingGrid[fromIdx] = null;
          renderHotbar();
          renderCrafting();
        }

        // limpiar selección de ambos
        pickedSlot.classList.remove('selected');
        slot.classList.remove('selected');
        pickedSlot = null;
      }
    };
  });
}

const buttons = ['left', 'right', 'jump', 'down', 'inventory-btn'];

buttons.forEach(id => {
  const btn = document.getElementById(id);

  // al presionar
  btn.addEventListener('touchstart', () => btn.classList.add('active'));
  btn.addEventListener('mousedown', () => btn.classList.add('active'));

  // al soltar
  btn.addEventListener('touchend', () => btn.classList.remove('active'));
  btn.addEventListener('mouseup', () => btn.classList.remove('active'));
  btn.addEventListener('mouseleave', () => btn.classList.remove('active'));
});

function renderHotbar() {
  const hotbars = [document.getElementById('hotbar-fixed'), document.querySelector('#inventory-panel #hotbar')];
  hotbars.forEach(hb => {
    const slots = hb.querySelectorAll('.slot');
    slots.forEach((btn, i) => {
      btn.innerHTML=''; // limpiar
      if(i<inventory.length){
        const slotData = inventory[i];
        if(slotData){
          const img = document.createElement('img');
          img.src = slotData.texture;
          img.style.width='100%';
          img.style.height='100%';
          btn.appendChild(img);

          if(slotData.count>1){
            if(slotData.count>1){
  const countDiv = document.createElement('div');
  countDiv.classList.add('count');
  countDiv.textContent = slotData.count;
  btn.appendChild(countDiv);
}

            const countDiv = document.createElement('div');
            countDiv.style.position='absolute';
            countDiv.style.bottom='2px';
            countDiv.style.right='2px';
            countDiv.style.color='white';
            countDiv.style.fontSize='12px';
            countDiv.textContent = slotData.count;
            btn.appendChild(countDiv);
          }
        }
      }
      
      btn.classList.toggle('selected', i===selectedSlot);
      btn.dataset.index = i;
      btn.onclick = ()=>{ selectedSlot=i; renderHotbar(); };
    });
  });
}

// inicializar
initInventorySelection();

function getBlock(wx, wy){
  let chunkX = Math.floor(wx/CHUNK_SIZE);
  let localX = wx - chunkX*CHUNK_SIZE;
  let chunk = generateChunk(chunkX);
  if(chunk.data[wy] && chunk.data[wy][localX] !== undefined) return chunk.data[wy][localX];
  return null;
}

function setBlock(wx, wy, type){
  let chunkX = Math.floor(wx/CHUNK_SIZE);
  let localX = wx - chunkX*CHUNK_SIZE;
  let chunk = generateChunk(chunkX);
  if(chunk.data[wy]) chunk.data[wy][localX] = type;
}
// ==== Manejo de la capa 2 (fondo) ====
function getBlockBg(wx, wy){
  let chunkX = Math.floor(wx/CHUNK_SIZE);
  let localX = wx - chunkX*CHUNK_SIZE;
  let chunk = generateChunkBg(chunkX);
  if(chunk.data[wy] && chunk.data[wy][localX] !== undefined) return chunk.data[wy][localX];
  return null;
}

function setBlockBg(wx, wy, type){
  let chunkX = Math.floor(wx/CHUNK_SIZE);
  let localX = wx - chunkX*CHUNK_SIZE;
  let chunk = generateChunkBg(chunkX);
  if(chunk.data[wy]) chunk.data[wy][localX] = type;
}

function drawChunks(){
  let startChunk = Math.floor((cameraX/BLOCK_SIZE)/CHUNK_SIZE) -1;
  let endChunk = Math.floor((cameraX + width)/BLOCK_SIZE/CHUNK_SIZE) +1;

  for(let cx=startChunk; cx<=endChunk; cx++){
    // --- Fondo (capa 2, más oscuro) ---
    let chunkBg = generateChunkBg(cx);
    for(let y=0; y<ROWS; y++){
      for(let x=0; x<CHUNK_SIZE; x++){
        const type = chunkBg.data[y][x];
        if(type){
          const tex = textures[type];
          if(tex.complete){
            ctx.save();
            ctx.globalAlpha = 0.9; // hace más oscuro
            ctx.drawImage(tex, (cx*CHUNK_SIZE + x)*BLOCK_SIZE - cameraX, y*BLOCK_SIZE - cameraY, BLOCK_SIZE, BLOCK_SIZE);
            ctx.fillStyle = "rgba(0,0,0,0.3)"; // sombra encima
            ctx.fillRect((cx*CHUNK_SIZE + x)*BLOCK_SIZE - cameraX, y*BLOCK_SIZE - cameraY, BLOCK_SIZE, BLOCK_SIZE);
            ctx.restore();
          }
        }
      }
    }

    // --- Frente (capa original, interactuable) ---
    let chunk = generateChunk(cx);
    for(let y=0; y<ROWS; y++){
      for(let x=0; x<CHUNK_SIZE; x++){
        const type = chunk.data[y][x];
        if(type){
          const tex = textures[type];
          if(tex.complete){
            ctx.drawImage(tex, (cx*CHUNK_SIZE + x)*BLOCK_SIZE - cameraX, y*BLOCK_SIZE - cameraY, BLOCK_SIZE, BLOCK_SIZE);
          }
        }
      }
    }
  }
}

document.getElementById('left').addEventListener('touchstart', () => {
  leftPressed = true;
  lastDirection = {dx:-1, dy:0};
  player.facing = -1; // mirando izquierda
});

document.getElementById('right').addEventListener('touchstart', () => {
  rightPressed = true;
  lastDirection = {dx:1, dy:0};
  player.facing = 1; // mirando derecha
});

// === Texturas del jugador ===
const playerFrames = [];
for (let i = 1; i <= 4; i++) {
  const img = new Image();
  img.src = `Texturas/Cubs${i}.png`;
  playerFrames.push(img);
}
const crouchFrames = [];
for (let i = 1; i <= 4; i++) {
  const img = new Image();
  img.src = `Texturas/Cub_agachado${i}.png`;
  crouchFrames.push(img);
}

let crouching = false; // variable que indica si el jugador está agachado

let currentFrame = 0;
let frameTimer = 0;

// Cambiamos el jugador a usar texturas
let player = { 
  x:5, y:30, width:0.8, height:0.8, 
  vx:0, vy:0, onGround:false, 
  facing: 1 // 1 = derecha, -1 = izquierda
};

// === Dibujar jugador con animación ===
function drawPlayer(dt) {
  const frames = crouching ? crouchFrames : playerFrames;

  // actualizar frame solo si se mueve y no solo por estar agachado
  if ((leftPressed || rightPressed)) {
    frameTimer += dt;
    if (frameTimer >= 0.2) { // 5 fps
      frameTimer = 0;
      currentFrame = (currentFrame + 1) % frames.length;
    }
  } else {
    currentFrame = 0; // si no se mueve, siempre frame inicial
  }

  const img = frames[currentFrame];
  if (!img.complete) return;

  const px = player.x*BLOCK_SIZE - cameraX;
  const py = player.y*BLOCK_SIZE - cameraY;
  const pw = player.width*BLOCK_SIZE;
  const ph = player.height*BLOCK_SIZE;

  ctx.save();
  if (player.facing === 1) {
    ctx.translate(px + pw, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(img, 0, py, pw, ph);
  } else {
    ctx.drawImage(img, px, py, pw, ph);
  }
  ctx.restore();
}


const gravity = 0.8;
const jumpPower = -15;
const playerSpeed = 0.12;
let speed = crouching ? playerSpeed * 0.4 : playerSpeed;

let cameraX=0, cameraY=0;

function isBlock(wx, wy){ return getBlock(Math.floor(wx), Math.floor(wy)) !== null; }

let collidingLeft=false, collidingRight=false, collidingTop=false, collidingBottom=false;
function movePlayer() {
  collidingLeft=false; collidingRight=false; collidingTop=false; collidingBottom=false;

  // --- Lógica de soporte al agacharse ---
  if(crouching && player.vx !== 0) {
    let ny = player.y + player.height + 0.01;
    let underCenter = isBlock(player.x + player.width/2, ny);

    if(player.vx < 0) { // izquierda
      let underLeft = isBlock(player.x, ny);
      if(!underLeft && !underCenter) player.vx = 0;
    } else if(player.vx > 0) { // derecha
      let underRight = isBlock(player.x + player.width, ny);
      if(!underRight && !underCenter) player.vx = 0;
    }
  }

  // --- Movimiento horizontal normal ---
  let nx = player.x + player.vx;
  if(player.vx < 0){
    if(!isBlock(nx, player.y) && !isBlock(nx + player.width, player.y) &&
       !isBlock(nx, player.y + player.height - 0.01) && !isBlock(nx + player.width, player.y + player.height - 0.01)) {
      player.x = nx;
    } else { 
      player.vx = 0; 
      collidingLeft = true; 
    }
  } else if(player.vx > 0){
    if(!isBlock(nx, player.y) && !isBlock(nx + player.width, player.y) &&
       !isBlock(nx, player.y + player.height - 0.01) && !isBlock(nx + player.width, player.y + player.height - 0.01)) {
      player.x = nx;
    } else { 
      player.vx = 0; 
      collidingRight = true; 
    }
  }

  // --- Movimiento vertical ---
  player.vy += gravity;
  let ny = player.y + player.vy / BLOCK_SIZE;
  player.onGround = false;

  if(player.vy > 0){ // cayendo
    if(!isBlock(player.x, ny + player.height) && !isBlock(player.x + player.width, ny + player.height)) {
      player.y = ny;
    } else {
      player.y = Math.floor(ny + player.height) - player.height;
      player.vy = 0; 
      player.onGround = true; 
      collidingBottom = true;
    }
  } else if(player.vy < 0){ // subiendo
    if(!isBlock(player.x, ny) && !isBlock(player.x + player.width, ny)) {
      player.y = ny;
    } else {
      player.vy = 0; 
      collidingTop = true;
    }
  }
}

function initInventorySlots() {
  const allSlots = document.querySelectorAll('#inventory-grid .slot');
  allSlots.forEach((slot, i)=>{
    slot.dataset.index = i+9; // los 9 primeros slots son hotbar
    slot.onclick = ()=>{
      if(selectedSlot!==null) renderHotbar(); // quitar anterior selección
      selectedSlot = parseInt(slot.dataset.index);
      renderHotbar();
      console.log('Slot seleccionado:', selectedSlot);
    };
  });
}
initInventorySlots();
renderHotbar();
let craftingGrid = new Array(4).fill(null); // 2x2
let craftResult = null;

function initCraftingSlots(){
  const craftSlots = document.querySelectorAll('.craft-slot');
  craftSlots.forEach((slot, i)=>{
    slot.dataset.index = i;
    slot.onclick = ()=>{
      // mover ítem desde inventario al slot de crafteo
      if(inventory[selectedSlot]){
        craftingGrid[i] = {...inventory[selectedSlot]};
        // quitar del inventario
        inventory[selectedSlot].count--;
        if(inventory[selectedSlot].count<=0) inventory[selectedSlot]=null;
        renderHotbar();
        renderCrafting();
        checkRecipes();
      }
    };
  });

  document.getElementById('craft-result').onclick = ()=>{
    if(craftResult){
      addItem(craftResult.type);
      // limpiar crafting grid
      craftingGrid = new Array(4).fill(null);
      craftResult = null;
      renderCrafting();
      renderHotbar();
    }
  };
}

function renderCrafting(){
  const craftSlots = document.querySelectorAll('.craft-slot');
  craftSlots.forEach((slot, i)=>{
    slot.innerHTML='';
    let item = craftingGrid[i];
    if(item){
      const img = document.createElement('img');
      img.src = item.texture;
      slot.appendChild(img);
    }
  });

  // resultado
  const resultSlot = document.getElementById('craft-result');
  resultSlot.innerHTML='';
  if(craftResult){
    const img = document.createElement('img');
    img.src = craftResult.texture;
    resultSlot.appendChild(img);
  }
}

initCraftingSlots();
const recipes = [
  {
    pattern: ['log', null,
              null, null],
    result: {type:'plank', texture:'Texturas/tablon.png'}
  },
  {
    pattern: ['plank','plank',
              'plank','plank'],
    result: {type:'crafting_table', texture:'Texturas/mesa_de_crafteo.png'}
  }
];

function checkRecipes(){
  craftResult = null;

  for(let recipe of recipes){
    let match = true;
    for(let i=0;i<4;i++){
      let need = recipe.pattern[i];
      let has = craftingGrid[i] ? craftingGrid[i].type : null;
      if(need !== has){
        match = false;
        break;
      }
    }
    if(match){
      craftResult = recipe.result;
      break;
    }
  }

  renderCrafting();
}

// Última dirección presionada (por defecto derecha)
// Última dirección presionada (por defecto derecha)
let lastDirection = {dx:1, dy:0};

// Variables de estado de los botones
let leftPressed = false, rightPressed = false, jumpPressed = false, downPressed = false;

// Controles táctiles y actualización de dirección
document.getElementById('left').addEventListener('touchstart', () => {
  leftPressed = true;
  lastDirection = {dx:-1, dy:0};
});
document.getElementById('left').addEventListener('touchend', () => leftPressed=false);

document.getElementById('right').addEventListener('touchstart', () => {
  rightPressed = true;
  lastDirection = {dx:1, dy:0};
});
document.getElementById('right').addEventListener('touchend', () => rightPressed=false);

document.getElementById('jump').addEventListener('touchstart', () => {
  jumpPressed = true;
  lastDirection = {dx:0, dy:-1}; // arriba
});
document.getElementById('jump').addEventListener('touchend', () => jumpPressed=false);

document.getElementById('down').addEventListener('touchstart', () => {
  if (breakMode) {
    lastDirection = {dx:0, dy:1}; // abajo
  } else {
    crouching = !crouching; // agacharse normal
  }
  downPressed = true;
});
document.getElementById('down').addEventListener('touchend', () => downPressed=false);

document.getElementById('down').addEventListener('touchend', () => {
  downPressed = false;
});

// Botón PRI
// === Botones PRI y BG ===
let breakMode = false;     // capa 1
let breakBgMode = false;   // capa 2

const priBtn = document.getElementById('pri-btn');
const priBgBtn = document.getElementById('pri-bg-btn');

// PRI (frente)
priBtn.addEventListener('touchstart', () => {
  breakMode = !breakMode;
  if(breakMode){
    priBtn.classList.add('active');
    breakBgMode = false;
    priBgBtn.classList.remove('active');
  } else {
    priBtn.classList.remove('active');
    stopBreaking();
  }
});

// BG (fondo)
priBgBtn.addEventListener('touchstart', () => {
  breakBgMode = !breakBgMode;
  if(breakBgMode){
    priBgBtn.classList.add('active');
    breakMode = false;
    priBtn.classList.remove('active');
  } else {
    priBgBtn.classList.remove('active');
    stopBreaking();
  }
});

// Datos de bloques
const blockData = {
  'stone': {time:30},
  'dirt': {time:5},
  'grass': {time:5},
  'log': {time:15},   // tronco → más resistente
  'leaf': {time:0.5}    // hoja → muy rápido
};


// Romper bloques
let breaking = {active:false, wx:0, wy:0, progress:0, time:0, type:null, delay:0};

function handleBreaking(dt){
  if((!breakMode && !breakBgMode) || !lastDirection) { stopBreaking(); return; }

  // Calculamos bloque objetivo según última dirección
  let wx, wy;
  if(lastDirection.dy > 0){
    wx = Math.floor(player.x + player.width/2);
    wy = Math.floor(player.y + player.height);
  } else if(lastDirection.dy < 0){
    wx = Math.floor(player.x + player.width/2);
    wy = Math.floor(player.y - 1);
  } else {
    wx = Math.floor(player.x + lastDirection.dx);
    wy = Math.floor(player.y + player.height/2);
  }

  // --- Diferencia entre capa 1 y capa 2 ---
  let type = breakMode ? getBlock(wx, wy) : getBlockBg(wx, wy);

  if(!type) { stopBreaking(); return; }

  if(!breaking.active || breaking.wx!==wx || breaking.wy!==wy){
    breaking.active = true;
    breaking.wx = wx;
    breaking.wy = wy;
    breaking.type = type;
    breaking.time = 0;
    breaking.progress = 0;
    breaking.delay = 0;
  }

  breaking.delay += dt;
  if(breaking.delay >= 0.5){
    updateBreaking(dt);
  }
}


function updateBreaking(dt){
  if(!breaking.active) return;

  let maxTime = 5;
  if(blockData[breaking.type]) maxTime = blockData[breaking.type].time;

  breaking.time += dt;
  breaking.progress = Math.min(breaking.time/maxTime,1);

  if(breaking.progress>=1){
    if(breakMode){
      // rompe capa 1
      setBlock(breaking.wx, breaking.wy, null);
      addItem(breaking.type);
    } 
    else if(breakBgMode){
      // rompe capa 2
      setBlockBg(breaking.wx, breaking.wy, null);
      addItem(breaking.type);   // ✅ ahora sí agrega al inventario
    }

    stopBreaking();
  }
}

function stopBreaking(){
  breaking.active=false;
  breaking.wx=0; breaking.wy=0; breaking.type=null; breaking.time=0; breaking.progress=0; breaking.delay=0;
}

function drawBreaking(){
  if(breaking.active && breaking.type){
    let stage = Math.floor(breaking.progress*4);
    let img = crackTextures[stage];
    if(img.complete) ctx.drawImage(img, breaking.wx*BLOCK_SIZE-cameraX, breaking.wy*BLOCK_SIZE-cameraY, BLOCK_SIZE, BLOCK_SIZE);
  }
}
function addItem(type){
  const textureMap = {
    stone: 'Texturas/piedra.jpg',
    dirt: 'Texturas/tierra.jpg',
    grass: 'Texturas/cesped_parte_costado.jpg',
    leaf: 'Texturas/oja.png',       // ✅ hojas
    log:  'Texturas/tronco.png'     // ✅ tronco
  };

  let tex = textureMap[type];
  if(!tex) return; // si no existe textura, no lo añade

  // Buscar stack existente
  let slot = inventory.find(s => s && s.type===type);
  if(slot){ 
    slot.count++; 
    renderHotbar(); 
    return; 
  }

  // Buscar primer slot vacío
  let emptyIndex = inventory.findIndex(s=>!s);
  if(emptyIndex>=0){ 
    inventory[emptyIndex] = {type, texture:tex, count:1}; 
    renderHotbar(); 
  }
  else console.log('Inventario lleno');
}

function placeBlock(wx, wy){
  const slot = inventory[selectedSlot];
  if(!slot) return;
  if(getBlock(wx, wy)===null){
    setBlock(wx, wy, slot.type);
    slot.count--;
    if(slot.count<=0) inventory[selectedSlot]=null;
    renderHotbar();
  }
}

// Touch para colocar bloque
canvas.addEventListener('touchstart', e=>{
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const cx = touch.clientX - rect.left;
  const cy = touch.clientY - rect.top;

  const wx = Math.floor((cx + cameraX)/BLOCK_SIZE);
  const wy = Math.floor((cy + cameraY)/BLOCK_SIZE);
  placeBlock(wx, wy);
});
function placeBlock(wx, wy){
  const slot = inventory[selectedSlot];
  if(!slot) return;
  if(getBlock(wx, wy)===null){
    setBlock(wx, wy, slot.type);
    slot.count--;
    if(slot.count<=0) inventory[selectedSlot]=null;
    renderHotbar();
  }
}

// Touch para colocar bloque
canvas.addEventListener('touchstart', e=>{
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const cx = touch.clientX - rect.left;
  const cy = touch.clientY - rect.top;

  const wx = Math.floor((cx + cameraX)/BLOCK_SIZE);
  const wy = Math.floor((cy + cameraY)/BLOCK_SIZE);
  placeBlock(wx, wy);
});

// Juego principal
let lastTime = performance.now();
function gameLoop(time){
  let dt = (time - lastTime)/1000;
  lastTime = time;

  ctx.clearRect(0,0,width,height);

// velocidad dinámica: normal o agachado
let speed = crouching ? playerSpeed * 0.4 : playerSpeed;

player.vx = 0;
if (leftPressed) player.vx = -speed;
if (rightPressed) player.vx = speed;

if (jumpPressed && player.onGround) player.vy = jumpPower;

  movePlayer();
  cameraX = player.x*BLOCK_SIZE - width/2 + BLOCK_SIZE/2;
  cameraY = player.y*BLOCK_SIZE - height/2 + BLOCK_SIZE/2;

  handleBreaking(dt);
  updateBreaking(dt);

  drawChunks();
  drawBreaking();

  drawPlayer(dt);

  requestAnimationFrame(gameLoop);
}
gameLoop();
</script>
</body>
</html>
